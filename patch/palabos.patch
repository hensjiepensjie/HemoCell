diff --git a/src/atomicBlock/atomicBlock3D.h b/src/atomicBlock/atomicBlock3D.h
index 68e6c7f..e30830d 100644
--- a/src/atomicBlock/atomicBlock3D.h
+++ b/src/atomicBlock/atomicBlock3D.h
@@ -183,6 +183,7 @@ private:
     StatSubscriber3D statisticsSubscriber;
     DataProcessorVector explicitInternalProcessors;
     DataProcessorVector automaticInternalProcessors;
+public:
     mutable BlockDataTransfer3D* dataTransfer;
 };
 
diff --git a/src/atomicBlock/blockLattice3D.h b/src/atomicBlock/blockLattice3D.h
index 05bd9a0..6ce0c00 100644
--- a/src/atomicBlock/blockLattice3D.h
+++ b/src/atomicBlock/blockLattice3D.h
@@ -52,7 +52,7 @@ namespace plb {
 
 template<typename T, template<typename U> class Descriptor> struct Dynamics;
 template<typename T, template<typename U> class Descriptor> class BlockLattice3D;
-
+template<typename T, template<typename U> class Descriptor> struct ImplicitGrid3D;
 
 template<typename T, template<typename U> class Descriptor>
 class BlockLatticeDataTransfer3D : public BlockDataTransfer3D {
@@ -140,14 +140,14 @@ public:
         PLB_PRECONDITION(iX<this->getNx());
         PLB_PRECONDITION(iY<this->getNy());
         PLB_PRECONDITION(iZ<this->getNz());
-        return grid[iX][iY][iZ];
+        return grid(iX,iY,iZ);
     }
     /// Read only access to lattice cells
     virtual Cell<T,Descriptor> const& get(plint iX, plint iY, plint iZ) const {
         PLB_PRECONDITION(iX<this->getNx());
         PLB_PRECONDITION(iY<this->getNy());
         PLB_PRECONDITION(iZ<this->getNz());
-        return grid[iX][iY][iZ];
+        return grid(iX,iY,iZ);
     }
     /// Specify wheter statistics measurements are done on a rect. domain
     virtual void specifyStatisticsStatus (
@@ -200,10 +200,10 @@ private:
     plint allocatedMemory() const;
 private:
     void periodicDomain(Box3D domain);
-private:
     Dynamics<T,Descriptor>* backgroundDynamics;
     Cell<T,Descriptor>     *rawData;
-    Cell<T,Descriptor>   ***grid;
+private:
+    ImplicitGrid3D<T,Descriptor> grid;
 public:
     static CachePolicy3D& cachePolicy();
     template<typename T_, template<typename U_> class Descriptor_>
@@ -218,6 +218,16 @@ public:
     friend class OnLinkExternalRhoJcollideAndStream3D;
     template<typename T_, template<typename U_> class Descriptor_>
     friend class GrayScaleCollideAndStream3D;
+    template<typename T_, template<typename U_> class Descriptor_>
+    friend class ImplicitGrid3D;
+};
+
+template<typename T, template<typename U> class Descriptor>
+struct ImplicitGrid3D {
+        BlockLattice3D<T,Descriptor>& parent;
+        ImplicitGrid3D(BlockLattice3D<T,Descriptor>& parent_);
+        const Cell<T,Descriptor> & operator () (int x,int y,int z) const;
+        Cell<T,Descriptor> & operator () (int x,int y,int z);
 };
 
 template<typename T, template<typename U> class Descriptor>
diff --git a/src/atomicBlock/blockLattice3D.hh b/src/atomicBlock/blockLattice3D.hh
index 815b086..1254c8e 100644
--- a/src/atomicBlock/blockLattice3D.hh
+++ b/src/atomicBlock/blockLattice3D.hh
@@ -64,7 +64,7 @@ BlockLattice3D<T,Descriptor>::BlockLattice3D (
         plint nx_, plint ny_, plint nz_,
         Dynamics<T,Descriptor>* backgroundDynamics_ )
    :  AtomicBlock3D(nx_, ny_, nz_, new BlockLatticeDataTransfer3D<T,Descriptor>()),
-      backgroundDynamics(backgroundDynamics_)
+      backgroundDynamics(backgroundDynamics_), grid(*this)
 {
     plint nx = this->getNx();
     plint ny = this->getNy();
@@ -74,7 +74,7 @@ BlockLattice3D<T,Descriptor>::BlockLattice3D (
     for (plint iX=0; iX<nx; ++iX) {
         for (plint iY=0; iY<ny; ++iY) {
             for (plint iZ=0; iZ<nz; ++iZ) {
-                grid[iX][iY][iZ].attributeDynamics(backgroundDynamics);
+                grid(iX,iY,iZ).attributeDynamics(backgroundDynamics);
             }
         }
     }
@@ -113,7 +113,8 @@ template<typename T, template<typename U> class Descriptor>
 BlockLattice3D<T,Descriptor>::BlockLattice3D(BlockLattice3D<T,Descriptor> const& rhs)
     : BlockLatticeBase3D<T,Descriptor>(rhs),
       AtomicBlock3D(rhs),
-      backgroundDynamics(rhs.backgroundDynamics->clone())
+      backgroundDynamics(rhs.backgroundDynamics->clone()),
+      grid(*this)
 {
     plint nx = this->getNx();
     plint ny = this->getNy();
@@ -122,9 +123,9 @@ BlockLattice3D<T,Descriptor>::BlockLattice3D(BlockLattice3D<T,Descriptor> const&
     for (plint iX=0; iX<nx; ++iX) {
         for (plint iY=0; iY<ny; ++iY) {
             for (plint iZ=0; iZ<nz; ++iZ) {
-                Cell<T,Descriptor>& cell = grid[iX][iY][iZ];
+                Cell<T,Descriptor>& cell = grid(iX,iY,iZ);
                 // Assign cell from rhs
-                cell = rhs.grid[iX][iY][iZ];
+                cell = rhs.grid(iX,iY,iZ);
                 // Get an independent clone of the dynamics,
                 //   or assign backgroundDynamics
                 if (&cell.getDynamics()==rhs.backgroundDynamics) {
@@ -176,7 +177,7 @@ void BlockLattice3D<T,Descriptor>::specifyStatisticsStatus(Box3D domain, bool st
     for (plint iX=domain.x0; iX<=domain.x1; ++iX) {
         for (plint iY=domain.y0; iY<=domain.y1; ++iY) {
             for (plint iZ=domain.z0; iZ<=domain.z1; ++iZ) {
-                grid[iX][iY][iZ].specifyStatisticsStatus(status);
+                grid(iX,iY,iZ).specifyStatisticsStatus(status);
             }
         }
     }
@@ -190,8 +191,8 @@ void BlockLattice3D<T,Descriptor>::collide(Box3D domain) {
     for (plint iX=domain.x0; iX<=domain.x1; ++iX) {
         for (plint iY=domain.y0; iY<=domain.y1; ++iY) {
             for (plint iZ=domain.z0; iZ<=domain.z1; ++iZ) {
-                grid[iX][iY][iZ].collide(this->getInternalStatistics());
-                grid[iX][iY][iZ].revert();
+                grid(iX,iY,iZ).collide(this->getInternalStatistics());
+                grid(iX,iY,iZ).revert();
             }
         }
     }
@@ -353,13 +354,6 @@ void BlockLattice3D<T,Descriptor>::allocateAndInitialize() {
     plint ny = this->getNy();
     plint nz = this->getNz();
     rawData = new Cell<T,Descriptor> [nx*ny*nz];
-    grid    = new Cell<T,Descriptor>** [nx];
-    for (plint iX=0; iX<nx; ++iX) {
-        grid[iX] = new Cell<T,Descriptor>* [ny];
-        for (plint iY=0; iY<ny; ++iY) {
-            grid[iX][iY] = rawData + nz*(iY+ny*iX);
-        }
-    }
 }
 
 template<typename T, template<typename U> class Descriptor>
@@ -370,7 +364,7 @@ void BlockLattice3D<T,Descriptor>::releaseMemory() {
     for (plint iX=0; iX<nx; ++iX) {
         for (plint iY=0; iY<ny; ++iY) {
             for (plint iZ=0; iZ<nz; ++iZ) {
-                Dynamics<T,Descriptor>* dynamics = &grid[iX][iY][iZ].getDynamics();
+                Dynamics<T,Descriptor>* dynamics = &grid(iX,iY,iZ).getDynamics();
                 if (dynamics != backgroundDynamics) {
                     delete dynamics;
                 }
@@ -379,21 +373,17 @@ void BlockLattice3D<T,Descriptor>::releaseMemory() {
     }
     delete backgroundDynamics;
     delete [] rawData;
-    for (plint iX=0; iX<nx; ++iX) {
-        delete [] grid[iX];
-    }
-    delete [] grid;
 }
 
 template<typename T, template<typename U> class Descriptor>
 void BlockLattice3D<T,Descriptor>::attributeDynamics (
         plint iX, plint iY, plint iZ, Dynamics<T,Descriptor>* dynamics )
 {
-    Dynamics<T,Descriptor>* previousDynamics = &grid[iX][iY][iZ].getDynamics();
+    Dynamics<T,Descriptor>* previousDynamics = &grid(iX,iY,iZ).getDynamics();
     if (previousDynamics != backgroundDynamics) {
         delete previousDynamics;
     }
-    grid[iX][iY][iZ].attributeDynamics(dynamics);
+    grid(iX,iY,iZ).attributeDynamics(dynamics);
 }
 
 template<typename T, template<typename U> class Descriptor>
@@ -444,8 +434,8 @@ void BlockLattice3D<T,Descriptor>::boundaryStream(Box3D bound, Box3D domain) {
                          nextY>=bound.y0 && nextY<=bound.y1 &&
                          nextZ>=bound.z0 && nextZ<=bound.z1 )
                     {
-                        std::swap(grid[iX][iY][iZ][iPop+Descriptor<T>::q/2],
-                                  grid[nextX][nextY][nextZ][iPop]);
+                        std::swap(grid(iX,iY,iZ)[iPop+Descriptor<T>::q/2],
+                                  grid(nextX,nextY,nextZ)[iPop]);
                     }
                 }
             }
@@ -470,8 +460,8 @@ void BlockLattice3D<T,Descriptor>::bulkStream(Box3D domain) {
                     plint nextX = iX + Descriptor<T>::c[iPop][0];
                     plint nextY = iY + Descriptor<T>::c[iPop][1];
                     plint nextZ = iZ + Descriptor<T>::c[iPop][2];
-                    std::swap(grid[iX][iY][iZ][iPop+Descriptor<T>::q/2],
-                              grid[nextX][nextY][nextZ][iPop]);
+                    std::swap(grid(iX,iY,iZ)[iPop+Descriptor<T>::q/2],
+                              grid(nextX,nextY,nextZ)[iPop]);
                 }
             }
         }
@@ -514,7 +504,7 @@ void BlockLattice3D<T,Descriptor>::linearBulkCollideAndStream(Box3D domain) {
     for (plint iX=domain.x0; iX<=domain.x1; ++iX) {
         for (plint iY=domain.y0; iY<=domain.y1; ++iY) {
             for (plint iZ=domain.z0; iZ<=domain.z1; ++iZ) {
-                grid[iX][iY][iZ].collide(this->getInternalStatistics());
+                grid(iX,iY,iZ).collide(this->getInternalStatistics());
                 latticeTemplates<T,Descriptor>::swapAndStream3D(grid, iX, iY, iZ);
             }
         }
@@ -564,7 +554,7 @@ void BlockLattice3D<T,Descriptor>::blockwiseBulkCollideAndStream(Box3D domain) {
                              ++innerZ)
                         {
                             // Collide the cell.
-                            grid[innerX][innerY][innerZ].collide (
+                            grid(innerX,innerY,innerZ).collide (
                                     this->getInternalStatistics() );
                             // Swap the populations on the cell, and then with post-collision
                             //   neighboring cell, to perform the streaming step.
@@ -647,8 +637,8 @@ void BlockLattice3D<T,Descriptor>::periodicDomain(Box3D domain) {
                         plint nextY = (iY+ny)%ny;
                         plint nextZ = (iZ+nz)%nz;
                         std::swap (
-                            grid[prevX][prevY][prevZ][indexTemplates::opposite<Descriptor<T> >(iPop)],
-                            grid[nextX][nextY][nextZ][iPop] );
+                            grid(prevX,prevY,prevZ)[indexTemplates::opposite<Descriptor<T> >(iPop)],
+                            grid(nextX,nextY,nextZ)[iPop] );
                     }
                 }
             }
@@ -656,6 +646,19 @@ void BlockLattice3D<T,Descriptor>::periodicDomain(Box3D domain) {
     }
 }
 
+
+template<typename T, template<typename U> class Descriptor>
+ImplicitGrid3D<T,Descriptor>::ImplicitGrid3D(BlockLattice3D<T,Descriptor>& parent_) : parent(parent_) {}
+
+template<typename T, template<typename U> class Descriptor>
+const Cell<T,Descriptor> & ImplicitGrid3D<T,Descriptor>::operator () (int x,int y,int z) const {
+            return parent.rawData[z + parent.getNz()*(y+parent.getNy()*x)];
+}
+template<typename T, template<typename U> class Descriptor>
+Cell<T,Descriptor> &ImplicitGrid3D<T,Descriptor>::operator () (int x,int y,int z) {
+            return parent.rawData[z + parent.getNz()*(y+parent.getNy()*x)];
+}
+
 ////////////////////// Class BlockLatticeDataTransfer3D /////////////////////////
 
 template<typename T, template<typename U> class Descriptor>
diff --git a/src/basicDynamics/dynamicsProcessor3D.hh b/src/basicDynamics/dynamicsProcessor3D.hh
index 950e729..00cae3b 100644
--- a/src/basicDynamics/dynamicsProcessor3D.hh
+++ b/src/basicDynamics/dynamicsProcessor3D.hh
@@ -103,8 +103,8 @@ void ExternalRhoJcollideAndStream3D<T,Descriptor>::boundaryStream (
                     if ( nextX>=bound.x0 && nextX<=bound.x1 && nextY>=bound.y0 && nextY<=bound.y1 &&
                          nextZ>=bound.z0 && nextZ<=bound.z1 )
                     {
-                        std::swap(lattice.grid[iX][iY][iZ][iPop+Descriptor<T>::q/2],
-                                  lattice.grid[nextX][nextY][nextZ][iPop]);
+                        std::swap(lattice.grid(iX,iY,iZ)[iPop+Descriptor<T>::q/2],
+                                  lattice.grid(nextX,nextY,nextZ)[iPop]);
                     }
                 }
             }
@@ -283,8 +283,8 @@ void PackedExternalRhoJcollideAndStream3D<T,Descriptor>::boundaryStream (
                     if ( nextX>=bound.x0 && nextX<=bound.x1 && nextY>=bound.y0 && nextY<=bound.y1 &&
                          nextZ>=bound.z0 && nextZ<=bound.z1 )
                     {
-                        std::swap(lattice.grid[iX][iY][iZ][iPop+Descriptor<T>::q/2],
-                                  lattice.grid[nextX][nextY][nextZ][iPop]);
+                        std::swap(lattice.grid(iX,iY,iZ)[iPop+Descriptor<T>::q/2],
+                                  lattice.grid(nextX,nextY,nextZ)[iPop]);
                     }
                 }
             }
@@ -507,8 +507,8 @@ void WaveAbsorptionExternalRhoJcollideAndStream3D<T,Descriptor>::boundaryStream
                     if ( nextX>=bound.x0 && nextX<=bound.x1 && nextY>=bound.y0 && nextY<=bound.y1 &&
                          nextZ>=bound.z0 && nextZ<=bound.z1 )
                     {
-                        std::swap(lattice.grid[iX][iY][iZ][iPop+Descriptor<T>::q/2],
-                                  lattice.grid[nextX][nextY][nextZ][iPop]);
+                        std::swap(lattice.grid(iX,iY,iZ)[iPop+Descriptor<T>::q/2],
+                                  lattice.grid(nextX,nextY,nextZ)[iPop]);
                     }
                 }
             }
@@ -650,7 +650,7 @@ void OnLinkExternalRhoJcollideAndStream3D<T,Descriptor>::collide (
 }
 
 template<typename T, template<typename U> class Descriptor>
-void onLinkSwapAndStream3D( Cell<T,Descriptor> ***grid,
+void onLinkSwapAndStream3D( ImplicitGrid3D<T,Descriptor> & grid,
                             plint iX, plint iY, plint iZ)
 {
     static int bbId = BounceBack<T,Descriptor>().getId();
@@ -659,16 +659,16 @@ void onLinkSwapAndStream3D( Cell<T,Descriptor> ***grid,
         plint nextX = iX + Descriptor<T>::c[iPop][0];
         plint nextY = iY + Descriptor<T>::c[iPop][1];
         plint nextZ = iZ + Descriptor<T>::c[iPop][2];
-        if (grid[iX][iY][iZ].getDynamics().getId()==bbId ||
-            grid[nextX][nextY][nextZ].getDynamics().getId()==bbId)
+        if (grid(iX,iY,iZ).getDynamics().getId()==bbId ||
+            grid(nextX,nextY,nextZ).getDynamics().getId()==bbId)
         {
-            std::swap(grid[iX][iY][iZ][iPop],grid[iX][iY][iZ][iPop+half]);
+            std::swap(grid(iX,iY,iZ)[iPop],grid(iX,iY,iZ)[iPop+half]);
         }
         else {
-            T fTmp                          = grid[iX][iY][iZ][iPop];
-            grid[iX][iY][iZ][iPop]          = grid[iX][iY][iZ][iPop+half];
-            grid[iX][iY][iZ][iPop+half]     = grid[nextX][nextY][nextZ][iPop];
-            grid[nextX][nextY][nextZ][iPop] = fTmp;
+            T fTmp                          = grid(iX,iY,iZ)[iPop];
+            grid(iX,iY,iZ)[iPop]          = grid(iX,iY,iZ)[iPop+half];
+            grid(iX,iY,iZ)[iPop+half]     = grid(nextX,nextY,nextZ)[iPop];
+            grid(nextX,nextY,nextZ)[iPop] = fTmp;
         }
      }
 }
@@ -711,11 +711,11 @@ void OnLinkExternalRhoJcollideAndStream3D<T,Descriptor>::boundaryStream (
                     if ( nextX>=bound.x0 && nextX<=bound.x1 && nextY>=bound.y0 && nextY<=bound.y1 &&
                          nextZ>=bound.z0 && nextZ<=bound.z1 )
                     {
-                        if (lattice.grid[iX][iY][iZ].getDynamics().getId()!=bbId &&
-                            lattice.grid[nextX][nextY][nextZ].getDynamics().getId()!=bbId)
+                        if (lattice.grid(iX,iY,iZ).getDynamics().getId()!=bbId &&
+                            lattice.grid(nextX,nextY,nextZ).getDynamics().getId()!=bbId)
                         {
-                            std::swap(lattice.grid[iX][iY][iZ][iPop+Descriptor<T>::q/2],
-                                      lattice.grid[nextX][nextY][nextZ][iPop]);
+                            std::swap(lattice.grid(iX,iY,iZ)[iPop+Descriptor<T>::q/2],
+                                      lattice.grid(nextX,nextY,nextZ)[iPop]);
                         }
                     }
                 }
diff --git a/src/basicDynamics/isoThermalDynamics.h b/src/basicDynamics/isoThermalDynamics.h
index 0997934..c8a74b4 100644
--- a/src/basicDynamics/isoThermalDynamics.h
+++ b/src/basicDynamics/isoThermalDynamics.h
@@ -40,6 +40,7 @@
 
 #include "core/globalDefs.h"
 #include "core/dynamics.h"
+#include "atomicBlock/blockLattice3D.h"
 
 namespace plb {
 
@@ -72,6 +73,12 @@ public:
     virtual void computeHeatFlux( Cell<T,Descriptor> const& cell,
                                   Array<T,Descriptor<T>::d>& q ) const;
 
+    // Compute the shear rate
+  //  virtual void computeShearRate (
+    //    Cell<T,Descriptor> const& cell,
+      //  BlockLattice3D<T, Descriptor>& lattice,
+        //Array<T,SymmetricTensor<T,Descriptor>::n>& shearrate, plint x, plint y, plint z) const;
+
 /* *************** Switch between population and moment representation ****** */
 
     /// Number of variables required to decompose a population representation into moments.
diff --git a/src/basicDynamics/isoThermalDynamics.hh b/src/basicDynamics/isoThermalDynamics.hh
index 3caf297..3dadf06 100644
--- a/src/basicDynamics/isoThermalDynamics.hh
+++ b/src/basicDynamics/isoThermalDynamics.hh
@@ -51,6 +51,7 @@
 #include <algorithm>
 #include <limits>
 #include <cstdlib>
+#include "atomicBlock/blockLattice3D.h"
 
 namespace plb {
 
diff --git a/src/core/cell.h b/src/core/cell.h
index 8807600..de508d7 100644
--- a/src/core/cell.h
+++ b/src/core/cell.h
@@ -58,7 +58,7 @@ public:
         PLB_PRECONDITION( index < ExternalField::numScalars );
         return data+index;
     }
-private:
+public:
     T data[ExternalField::numScalars];
 };
 
@@ -170,7 +170,7 @@ public:
     void specifyStatisticsStatus(bool status) {
         takesStat = status;
     }
-private:
+public:
     /// You can't use this method. Use BlockLattice::attributeDynamics instead.
     /** This is one of the rare cases of a method accepting a pointer but
      *  not managing memory itself. Memory of the dynamics is handled by
@@ -380,7 +380,9 @@ private:
     void iniExternal();
 private:
     Array<T,Descriptor<T>::numPop> f;         ///< distribution functions
+public:
     External                       external;  ///< external scalars
+private:
     bool                           takesStat; ///< is statistics taken?
     Dynamics<T,Descriptor>*        dynamics;  ///< local LB dynamics
 };
diff --git a/src/core/dynamics.h b/src/core/dynamics.h
index d9654cd..a528ccc 100644
--- a/src/core/dynamics.h
+++ b/src/core/dynamics.h
@@ -38,6 +38,10 @@
 #ifndef DYNAMICS_H
 #define DYNAMICS_H
 
+namespace plb {
+template<typename T, template<typename U> class Descriptor> struct Dynamics;
+}
+
 #include "core/globalDefs.h"
 #include "core/util.h"
 #include "core/blockStatistics.h"
@@ -155,7 +159,7 @@ struct Dynamics {
         Cell<T,Descriptor> const& cell, Array<T,SymmetricTensor<T,Descriptor>::n>& stress ) const =0;
     /// Compute the heat flux in lattice units
     virtual void computeHeatFlux( Cell<T,Descriptor> const& cell,
-                                  Array<T,Descriptor<T>::d>& q ) const =0;
+                                  Array<T,Descriptor<T>::d>& q ) const =0; 
     /// Compute additional user-defined moments
     virtual void computeMoment( Cell<T,Descriptor> const& cell,
                                 plint momentId, T* moment ) const =0;
diff --git a/src/core/globalDefs.h b/src/core/globalDefs.h
index 3c4bf44..4cb8a2d 100644
--- a/src/core/globalDefs.h
+++ b/src/core/globalDefs.h
@@ -196,10 +196,12 @@ namespace modif {
         dynamicVariables =2,  //< Only content of dynamics objects, but no static content.
         allVariables     =3,  //< Both the static and dynamic cell content.
         dataStructure    =4,  //< Recreate dynamics and copy both static and dynamic content.
-        undefined        =5   
+        undefined        =5,
+        hemocell         =6,
+        hemocell_no_comm =7, //< Update envelopes but dont automatically send
     };
 
-    enum { numConstants=5 };
+    enum { numConstants=6 };
 
     /// If two data processors act on a block, combine their ModifT modification to
     ///   determine a resulting (worst-case) ModifT modification.
diff --git a/src/core/plbInit.cpp b/src/core/plbInit.cpp
index 1aeb37b..8ae00bd 100644
--- a/src/core/plbInit.cpp
+++ b/src/core/plbInit.cpp
@@ -46,7 +46,7 @@ namespace plb {
 
 void plbInit(int *argc, char ***argv, bool verbous) {
     global::mpi().init(argc, argv, verbous);
-    global::mainArguments().setArgs(*argc, argv);
+    //global::mainArguments().setArgs(*argc, argv);
     global::plbRandom<float>().seed(10);
     global::plbRandom<double>().seed(10);
     global::plbRandom<plint>().seed(10);
diff --git a/src/dataProcessors/dataAnalysisFunctional3D.hh b/src/dataProcessors/dataAnalysisFunctional3D.hh
index bb9a42b..e77bfac 100644
--- a/src/dataProcessors/dataAnalysisFunctional3D.hh
+++ b/src/dataProcessors/dataAnalysisFunctional3D.hh
@@ -1969,7 +1969,7 @@ void BoxStrainRateFromStressFunctional3D<T,Descriptor>::process (
             for (plint iZ=domain.z0; iZ<=domain.z1; ++iZ) {
                 Cell<T,Descriptor> const& cell = lattice.get(iX,iY,iZ);
                 Array<T,SymmetricTensor<T,Descriptor>::n>& element
-                    = S.get(iX+offset.x,iY+offset.y,iZ+offset.z);
+                    = S.get(iX,iY,iZ);
                 cell.computePiNeq(element);
                 T omega     = cell.getDynamics().getOmega();
                 if (cell.getDynamics().hasMoments()) {
diff --git a/src/latticeBoltzmann/latticeTemplates.h b/src/latticeBoltzmann/latticeTemplates.h
index dd9bc8f..dc57862 100644
--- a/src/latticeBoltzmann/latticeTemplates.h
+++ b/src/latticeBoltzmann/latticeTemplates.h
@@ -65,7 +65,7 @@ static void swapAndStream2D(Cell<T,Descriptor> **grid, plint iX, plint iY)
 }
 
 /// Swap ("bounce-back") values of a cell (3D), and apply streaming step
-static void swapAndStream3D(Cell<T,Descriptor> ***grid,
+static void swapAndStream3D(ImplicitGrid3D<T, Descriptor> & grid,
                             plint iX, plint iY, plint iZ)
 {
     const plint half = Descriptor<T>::q/2;
@@ -73,10 +73,10 @@ static void swapAndStream3D(Cell<T,Descriptor> ***grid,
         plint nextX = iX + Descriptor<T>::c[iPop][0];
         plint nextY = iY + Descriptor<T>::c[iPop][1];
         plint nextZ = iZ + Descriptor<T>::c[iPop][2];
-        T fTmp                          = grid[iX][iY][iZ][iPop];
-        grid[iX][iY][iZ][iPop]          = grid[iX][iY][iZ][iPop+half];
-        grid[iX][iY][iZ][iPop+half]     = grid[nextX][nextY][nextZ][iPop];
-        grid[nextX][nextY][nextZ][iPop] = fTmp;
+        T fTmp                          = grid(iX,iY,iZ)[iPop];
+        grid(iX,iY,iZ)[iPop]          = grid(iX,iY,iZ)[iPop+half];
+        grid(iX,iY,iZ)[iPop+half]     = grid(nextX,nextY,nextZ)[iPop];
+        grid(nextX,nextY,nextZ)[iPop] = fTmp;
      }
 }
 
diff --git a/src/latticeBoltzmann/latticeTemplates3D.h b/src/latticeBoltzmann/latticeTemplates3D.h
index 3b9a871..d0054d3 100644
--- a/src/latticeBoltzmann/latticeTemplates3D.h
+++ b/src/latticeBoltzmann/latticeTemplates3D.h
@@ -40,6 +40,8 @@
 
 #include "core/globalDefs.h"
 #include "latticeBoltzmann/nearestNeighborLattices3D.h"
+#include "nearestNeighborLattices3D.h"
+#include "atomicBlock/blockLattice3D.h"
 
 namespace plb {
 
@@ -47,16 +49,16 @@ template<typename T>
 struct latticeTemplates<T, descriptors::D3Q19Descriptor> {
 
 static void swapAndStreamCell (
-      Cell<T,descriptors::D3Q19Descriptor> ***grid,
+      ImplicitGrid3D<T, descriptors::D3Q19Descriptor> & grid,
       plint iX, plint iY, plint iZ, plint nX, plint nY, plint nZ, plint iPop, T& fTmp )
 {
-    fTmp                     = grid[iX][iY][iZ][iPop];
-    grid[iX][iY][iZ][iPop]   = grid[iX][iY][iZ][iPop+9];
-    grid[iX][iY][iZ][iPop+9] = grid[nX][nY][nZ][iPop];
-    grid[nX][nY][nZ][iPop]   = fTmp;
+    fTmp                     = grid(iX,iY,iZ)[iPop];
+    grid(iX,iY,iZ)[iPop]   = grid(iX,iY,iZ)[iPop+9];
+    grid(iX,iY,iZ)[iPop+9] = grid(nX,nY,nZ)[iPop];
+    grid(nX,nY,nZ)[iPop]   = fTmp;
 }
 
-static void swapAndStream3D(Cell<T,descriptors::D3Q19Descriptor> ***grid,
+static void swapAndStream3D(ImplicitGrid3D<T, descriptors::D3Q19Descriptor> & grid,
                             plint iX, plint iY, plint iZ)
 {
     T fTmp;
@@ -77,16 +79,16 @@ template<typename T>
 struct latticeTemplates<T, descriptors::ForcedD3Q19Descriptor> {
 
 static void swapAndStreamCell (
-      Cell<T,descriptors::ForcedD3Q19Descriptor> ***grid,
+      ImplicitGrid3D<T, descriptors::ForcedD3Q19Descriptor> & grid,
       plint iX, plint iY, plint iZ, plint nX, plint nY, plint nZ, plint iPop, T& fTmp )
 {
-    fTmp                     = grid[iX][iY][iZ][iPop];
-    grid[iX][iY][iZ][iPop]   = grid[iX][iY][iZ][iPop+9];
-    grid[iX][iY][iZ][iPop+9] = grid[nX][nY][nZ][iPop];
-    grid[nX][nY][nZ][iPop]   = fTmp;
+    fTmp                     = grid(iX,iY,iZ)[iPop];
+    grid(iX,iY,iZ)[iPop]   = grid(iX,iY,iZ)[iPop+9];
+    grid(iX,iY,iZ)[iPop+9] = grid(nX,nY,nZ)[iPop];
+    grid(nX,nY,nZ)[iPop]   = fTmp;
 }
 
-static void swapAndStream3D(Cell<T,descriptors::ForcedD3Q19Descriptor> ***grid,
+static void swapAndStream3D(ImplicitGrid3D<T, descriptors::ForcedD3Q19Descriptor> & grid,
                             plint iX, plint iY, plint iZ)
 {
     T fTmp;
@@ -107,16 +109,16 @@ template<typename T>
 struct latticeTemplates<T, descriptors::D3Q15Descriptor> {
 
 static void swapAndStreamCell (
-      Cell<T,descriptors::D3Q15Descriptor> ***grid,
+      ImplicitGrid3D<T, descriptors::D3Q15Descriptor> & grid,
       plint iX, plint iY, plint iZ, plint nX, plint nY, plint nZ, plint iPop, T& fTmp )
 {
-    fTmp                     = grid[iX][iY][iZ][iPop];
-    grid[iX][iY][iZ][iPop]   = grid[iX][iY][iZ][iPop+7];
-    grid[iX][iY][iZ][iPop+7] = grid[nX][nY][nZ][iPop];
-    grid[nX][nY][nZ][iPop]   = fTmp;
+    fTmp                     = grid(iX,iY,iZ)[iPop];
+    grid(iX,iY,iZ)[iPop]   = grid(iX,iY,iZ)[iPop+7];
+    grid(iX,iY,iZ)[iPop+7] = grid(nX,nY,nZ)[iPop];
+    grid(nX,nY,nZ)[iPop]   = fTmp;
 }
 
-static void swapAndStream3D(Cell<T,descriptors::D3Q15Descriptor> ***grid,
+static void swapAndStream3D(ImplicitGrid3D<T, descriptors::D3Q15Descriptor> & grid,
                             plint iX, plint iY, plint iZ)
 {
     T fTmp;
@@ -136,16 +138,16 @@ template<typename T>
 struct latticeTemplates<T, descriptors::ForcedD3Q15Descriptor> {
 
 static void swapAndStreamCell (
-      Cell<T,descriptors::ForcedD3Q15Descriptor> ***grid,
+      ImplicitGrid3D<T, descriptors::ForcedD3Q15Descriptor> & grid,
       plint iX, plint iY, plint iZ, plint nX, plint nY, plint nZ, plint iPop, T& fTmp )
 {
-    fTmp                     = grid[iX][iY][iZ][iPop];
-    grid[iX][iY][iZ][iPop]   = grid[iX][iY][iZ][iPop+7];
-    grid[iX][iY][iZ][iPop+7] = grid[nX][nY][nZ][iPop];
-    grid[nX][nY][nZ][iPop]   = fTmp;
+    fTmp                     = grid(iX,iY,iZ)[iPop];
+    grid(iX,iY,iZ)[iPop]   = grid(iX,iY,iZ)[iPop+7];
+    grid(iX,iY,iZ)[iPop+7] = grid(nX,nY,nZ)[iPop];
+    grid(nX,nY,nZ)[iPop]   = fTmp;
 }
 
-static void swapAndStream3D(Cell<T,descriptors::ForcedD3Q15Descriptor> ***grid,
+static void swapAndStream3D(ImplicitGrid3D<T, descriptors::ForcedD3Q15Descriptor> & grid,
                             plint iX, plint iY, plint iZ)
 {
     T fTmp;
diff --git a/src/libraryInterfaces/TINYXML_xmlIO.cpp b/src/libraryInterfaces/TINYXML_xmlIO.cpp
index 924abba..97ab071 100644
--- a/src/libraryInterfaces/TINYXML_xmlIO.cpp
+++ b/src/libraryInterfaces/TINYXML_xmlIO.cpp
@@ -1,436 +1,437 @@
-/* This file is part of the Palabos library.
-*
-* The Palabos softare is developed since 2011 by FlowKit-Numeca Group Sarl
-* (Switzerland) and the University of Geneva (Switzerland), which jointly
-* own the IP rights for most of the code base. Since October 2019, the
-* Palabos project is maintained by the University of Geneva and accepts
-* source code contributions from the community.
-*
-* Contact:
-* Jonas Latt
-* Computer Science Department
-* University of Geneva
-* 7 Route de Drize
-* 1227 Carouge, Switzerland
-* jonas.latt@unige.ch
-*
-* The most recent release of Palabos can be downloaded at
-* <https://palabos.unige.ch/>
-*
-* The library Palabos is free software: you can redistribute it and/or
-* modify it under the terms of the GNU Affero General Public License as
-* published by the Free Software Foundation, either version 3 of the
-* License, or (at your option) any later version.
-*
-* The library is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU Affero General Public License for more details.
-*
-* You should have received a copy of the GNU Affero General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/** \file
- * Input/Output in XML format -- non-generic code.
- */
-
-#include "core/globalDefs.h"
-#include "core/plbDebug.h"
-#include "core/util.h"
-#include "libraryInterfaces/TINYXML_xmlIO.h"
-#include "libraryInterfaces/TINYXML_xmlIO.hh"
-#include "core/runTimeDiagnostics.h"
-#include "parallelism/mpiManager.h"
-#include "io/parallelIO.h"
-#include <algorithm>
-#include <cctype>
-
-namespace plb {
-
-XMLreader XMLreader::notFound;
-
-XMLreader::XMLreader( std::vector<TiXmlNode*> pParentVect )
-{
-    if (global::mpi().isMainProcessor()) {
-        mainProcessorIni(pParentVect);
-    }
-    else {
-        slaveProcessorIni();
-    }
-}
-
-XMLreader::XMLreader( std::string fName )
-{
-
-    TiXmlDocument* doc = 0;
-    bool loadOK = false;
-    std::string errorMessage;
-    if (global::mpi().isMainProcessor()) {
-        doc = new TiXmlDocument(fName.c_str());
-        loadOK = doc->LoadFile();
-        if (!loadOK) {
-            errorMessage = "Problem processing input XML file " + fName + ": " + doc->ErrorDesc();
-        }
-    }
-
-    global::mpi().bCast(errorMessage);
-    plbMainProcIOError(!loadOK, errorMessage);
-
-    if (global::mpi().isMainProcessor()) {
-        mainProcessorIni(doc);
-        delete doc;
-    }
-    else {
-        slaveProcessorIni();
-    }
-}
-
-//Transform a string into a xml object
-void XMLreader::XMLreader_parse_from_string(const char * raw_xml){
-    TiXmlDocument *doc = new TiXmlDocument();
-    doc->Parse(raw_xml, 0, TIXML_ENCODING_UTF8);
-    if (global::mpi().isMainProcessor()) {
-        mainProcessorIni(doc);
-    }
-    else {
-        slaveProcessorIni();
-    }
-}
-
-void XMLreader::mainProcessorIni( TiXmlNode* pParent ) {
-    std::vector<TiXmlNode*> pParentVect;
-    pParentVect.push_back(pParent);
-    mainProcessorIni(pParentVect);
-}
-
-void XMLreader::mainProcessorIni( std::vector<TiXmlNode*> pParentVect )
-{
-    std::map<plint, TiXmlNode*> parents;
-    for (pluint iParent=0; iParent<pParentVect.size(); ++iParent) {
-        PLB_PRECONDITION( pParentVect[iParent]->Type()==TiXmlNode::DOCUMENT ||
-                          pParentVect[iParent]->Type()==TiXmlNode::ELEMENT );
-
-        TiXmlElement* pParentElement = pParentVect[iParent]->ToElement();
-        plint id=0;
-        if (pParentElement) {
-            const char* attribute = pParentElement->Attribute("id");
-            if (attribute) {
-                std::stringstream attributestr(attribute);
-                attributestr >> id;
-            }
-        }
-        parents[id] = pParentVect[iParent];
-    }
-
-    plint numId = (plint)parents.size();
-    global::mpi().bCast(&numId, 1);
-
-    std::map<plint, TiXmlNode*>::iterator it = parents.begin();
-    name = it->second->ValueStr();
-    global::mpi().bCast(name);
-
-    for (; it != parents.end(); ++it) {
-        plint id = it->first;
-        global::mpi().bCast(&id, 1);
-
-        TiXmlNode* pParent = it->second;
-        Data& data = data_map[id];
-        data.text="";
-
-        typedef std::map<std::string, std::vector<TiXmlNode*> > ChildMap;
-        ChildMap childMap;
-        TiXmlNode* pChild;
-        for ( pChild = pParent->FirstChild(); pChild != 0; pChild = pChild->NextSibling()) 
-        {
-            int type = pChild->Type();
-            if ( type==TiXmlNode::ELEMENT ) {
-                std::string name(pChild->Value());
-                childMap[name].push_back(pChild);
-            }
-            else if ( type==TiXmlNode::TEXT ) {
-                data.text = pChild->ToText()->ValueStr();
-            }
-        }
-        global::mpi().bCast(data.text);
-        plint numChildren = (plint) childMap.size();
-        global::mpi().bCast(&numChildren, 1);
-
-        for (ChildMap::iterator it = childMap.begin(); it != childMap.end(); ++it) {
-            std::vector<TiXmlNode*> pChildVect = it->second;
-            data.children.push_back( new XMLreader( pChildVect ) );
-        }
-    }
-}
-
-void XMLreader::slaveProcessorIni()
-{
-    plint numId = 0;
-    global::mpi().bCast(&numId, 1);
-    global::mpi().bCast(name);
-
-    for (plint iId=0; iId<numId; ++iId) {
-        plint id=0;
-        global::mpi().bCast(&id, 1);
-        Data& data = data_map[id];
-        global::mpi().bCast(data.text);
-        plint numChildren=0;
-        global::mpi().bCast(&numChildren, 1);
-
-        for(plint iChild=0; iChild<numChildren; ++iChild) {
-            std::vector<TiXmlNode*> noParam;
-            data.children.push_back( new XMLreader(noParam) );
-        }
-    }
-}
-
-XMLreader::XMLreader() {
-    name = "XML node not found";
-}
-
-XMLreader::~XMLreader() {
-    std::map<plint,Data>::iterator it = data_map.begin();
-    for (; it != data_map.end(); ++it) {
-        std::vector<XMLreader*>& children = it->second.children;
-        for (pluint iNode=0; iNode<children.size(); ++iNode) {
-            delete children[iNode];
-        }
-    }
-}
-
-void XMLreader::print(int indent) const {
-    std::string indentStr(indent, ' ');
-    pcout << indentStr << "[" << name << "]" << std::endl;
-    std::string text = getFirstText();
-    if (!text.empty()) {
-        pcout << indentStr << "  " << text << std::endl;
-    }
-    std::vector<XMLreader*> const& children = data_map.begin()->second.children;
-    for (pluint iNode=0; iNode<children.size(); ++iNode) {
-        children[iNode]->print(indent+2);
-    }
-}
-
-XMLreaderProxy XMLreader::operator[] (std::string name) const
-{
-    Data const& data = data_map.begin()->second;
-    for (pluint iNode=0; iNode<data.children.size(); ++iNode) {
-        if (data.children[iNode]->name == name) {
-            return XMLreaderProxy(data.children[iNode]);
-        }
-    }
-    plbIOError( std::string("Element ")+name+std::string(" not found in XML file.") );
-    return XMLreaderProxy(0);
-}
-
-XMLreaderProxy XMLreader::getElement(std::string name, plint id) const {
-    std::map<plint,Data>::const_iterator it = data_map.find(id);
-    if (it==data_map.end()) {
-        std::stringstream idStr;
-        idStr << id;
-        plbIOError (
-                std::string("Element with id ") +
-                idStr.str() + std::string(" does not exist") );
-    }
-    std::vector<XMLreader*> const& children = it->second.children;
-    for (pluint iNode=0; iNode<children.size(); ++iNode) {
-        if (children[iNode]->name == name) {
-            return XMLreaderProxy(children[iNode]);
-        }
-    }
-    plbIOError( std::string("Element ")+name+std::string(" not found in XML file.") );
-    return XMLreaderProxy(0);
-}
-
-std::string XMLreader::getName() const {
-    return name;
-}
-
-std::string XMLreader::getText() const {
-    return data_map.begin()->second.text;
-}
-
-std::string XMLreader::getText(plint id) const {
-    std::map<plint,Data>::const_iterator it = data_map.find(id);
-    if (it != data_map.end()) {
-        return it->second.text;
-    }
-    else {
-        return "";
-    }
-}
-
-plint XMLreader::getFirstId() const {
-    return data_map.begin()->first;
-}
-
-std::string XMLreader::getFirstText() const {
-    return data_map.begin()->second.text;
-}
-
-bool XMLreader::idExists(plint id) const {
-    std::map<plint,Data>::const_iterator it = data_map.find(id);
-    if (it != data_map.end()) {
-        return true;
-    }
-    else {
-        return false;
-    }
-}
-
-bool XMLreader::getNextId(plint& id) const {
-    std::map<plint,Data>::const_iterator it = data_map.find(id);
-    if (it != data_map.end()) {
-        ++it;
-        if (it != data_map.end()) {
-            id = it->first;
-            return true;
-        }
-    }
-    return false;
-}
-
-std::vector<XMLreader*> const& XMLreader::getChildren(plint id) const
-{
-    std::map<plint,Data>::const_iterator it = data_map.find(id);
-    if (it==data_map.end()) {
-        plbIOError(std::string("Cannot access id ")+util::val2str(id)+" in XML element " + name);
-    }
-    return it->second.children;
-}
-
-XMLreaderProxy::XMLreaderProxy(XMLreader const* reader_)
-    : reader(reader_)
-{
-    if (reader) {
-        id = reader->getFirstId();
-    }
-    else {
-        id = 0;
-    }
-}
-
-XMLreaderProxy::XMLreaderProxy(XMLreader const* reader_, plint id_)
-    : reader(reader_),
-      id(id_)
-{ }
-
-XMLreaderProxy XMLreaderProxy::operator[] (std::string name) const
-{
-    if (!reader) {
-        plbIOError(std::string("Cannot read value from XML element ") + name);
-    }
-    return reader->getElement(name, id);
-}
-
-XMLreaderProxy XMLreaderProxy::operator[] (plint newId) const {
-    if (!reader) {
-        plbIOError(std::string("Cannot read value from XML element"));
-    }
-    if (!reader->idExists(newId)) {
-        std::stringstream newIdStr;
-        newIdStr << newId;
-        plbIOError (
-                std::string("Id ") + newIdStr.str() +
-                std::string(" does not exist in XML element") );
-    }
-    return XMLreaderProxy(reader, newId);
-}
-
-bool XMLreaderProxy::isValid() const {
-    return reader;
-}
-
-plint XMLreaderProxy::getId() const {
-    return id;
-}
-
-XMLreaderProxy XMLreaderProxy::iterId() const {
-    if (!reader) {
-        plbIOError(std::string("Use of invalid XML element"));
-    }
-    plint newId = id;
-    if (reader->getNextId(newId)) {
-        return XMLreaderProxy(reader, newId);
-    }
-    else {
-        return XMLreaderProxy(0);
-    }
-}
-
-std::string XMLreaderProxy::getName() const {
-    if (!reader) {
-        plbIOError(std::string("Cannot read value from XML element "));
-    }
-    return reader->getName();
-}
-
-std::vector<XMLreader*> const& XMLreaderProxy::getChildren() const {
-    if (!reader) {
-        plbIOError(std::string("Cannot read value from XML element "));
-    }
-    return reader->getChildren(id);
-}
-
-
-XMLwriter::XMLwriter()
-    : isDocument(true),
-      currentId(0)
-{ }
-
-XMLwriter::~XMLwriter() {
-    std::map<plint,Data>::iterator it = data_map.begin();
-    for (; it != data_map.end(); ++it) {
-        std::vector<XMLwriter*>& children = it->second.children;
-        for (pluint iNode=0; iNode<children.size(); ++iNode) {
-            delete children[iNode];
-        }
-    }
-}
-
-XMLwriter::XMLwriter(std::string name_)
-    : isDocument(false),
-      name(name_),
-      currentId(0)
-{ }
-
-void XMLwriter::setString(std::string const& value)
-{
-    data_map[currentId].text = value;
-}
-
-
-XMLwriter& XMLwriter::operator[] (std::string name) {
-    std::vector<XMLwriter*>& children = data_map[currentId].children;
-    // If node already exists, simply return it.
-    for (pluint iNode=0; iNode<data_map[currentId].children.size(); ++iNode) {
-        if (data_map[currentId].children[iNode]->name == name) {
-            return *children[iNode];
-        }
-    }
-    // Else, create and return it.
-    children.push_back(new XMLwriter(name));
-    return *children.back();
-}
-
-XMLwriter& XMLwriter::operator[] (plint id) {
-    currentId = id;
-    return *this;
-}
-
-void XMLwriter::print(std::string fName) const {
-    plb_ofstream ofile(fName.c_str());
-    plbIOError( !ofile.is_open(), std::string("Could not open file ") + fName
-                                  + std::string(" for write access") );
-    toOutputStream(ofile);
-}
-
-std::string XMLwriter::sprint()
-{
-    std::stringstream a;
-    toOutputStream_parrallel(a);
-    return a.str();
-}
-
-
-}  // namespace plb
+/* This file is part of the Palabos library.
+*
+* The Palabos softare is developed since 2011 by FlowKit-Numeca Group Sarl
+* (Switzerland) and the University of Geneva (Switzerland), which jointly
+* own the IP rights for most of the code base. Since October 2019, the
+* Palabos project is maintained by the University of Geneva and accepts
+* source code contributions from the community.
+*
+* Contact:
+* Jonas Latt
+* Computer Science Department
+* University of Geneva
+* 7 Route de Drize
+* 1227 Carouge, Switzerland
+* jonas.latt@unige.ch
+*
+* The most recent release of Palabos can be downloaded at
+* <https://palabos.unige.ch/>
+*
+* The library Palabos is free software: you can redistribute it and/or
+* modify it under the terms of the GNU Affero General Public License as
+* published by the Free Software Foundation, either version 3 of the
+* License, or (at your option) any later version.
+*
+* The library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Affero General Public License for more details.
+*
+* You should have received a copy of the GNU Affero General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/** \file
+ * Input/Output in XML format -- non-generic code.
+ */
+
+#include "core/globalDefs.h"
+#include "core/plbDebug.h"
+#include "core/util.h"
+#include "libraryInterfaces/TINYXML_xmlIO.h"
+#include "libraryInterfaces/TINYXML_xmlIO.hh"
+#include "core/runTimeDiagnostics.h"
+#include "parallelism/mpiManager.h"
+#include "io/parallelIO.h"
+#include <algorithm>
+#include <cctype>
+
+namespace plb {
+
+XMLreader XMLreader::notFound;
+
+XMLreader::XMLreader( std::vector<TiXmlNode*> pParentVect )
+{
+    if (global::mpi().isMainProcessor()) {
+        mainProcessorIni(pParentVect);
+    }
+    else {
+        slaveProcessorIni();
+    }
+}
+
+XMLreader::XMLreader( std::string fName )
+{
+
+    TiXmlDocument* doc = 0;
+    bool loadOK = false;
+    std::string errorMessage;
+    if (global::mpi().isMainProcessor()) {
+        doc = new TiXmlDocument(fName.c_str());
+        loadOK = doc->LoadFile();
+        if (!loadOK) {
+            errorMessage = "Problem processing input XML file " + fName + ": " + doc->ErrorDesc();
+        }
+    }
+
+    global::mpi().bCast(errorMessage);
+    plbMainProcIOError(!loadOK, errorMessage);
+
+    if (global::mpi().isMainProcessor()) {
+        mainProcessorIni(doc);
+        delete doc;
+    }
+    else {
+        slaveProcessorIni();
+    }
+}
+
+//Transform a string into a xml object
+void XMLreader::XMLreader_parse_from_string(const char * raw_xml){
+    TiXmlDocument *doc = new TiXmlDocument();
+    doc->Parse(raw_xml, 0, TIXML_ENCODING_UTF8);
+    if (global::mpi().isMainProcessor()) {
+        mainProcessorIni(doc);
+    }
+    else {
+        slaveProcessorIni();
+    }
+}
+
+void XMLreader::mainProcessorIni( TiXmlNode* pParent ) {
+    std::vector<TiXmlNode*> pParentVect;
+    pParentVect.push_back(pParent);
+    mainProcessorIni(pParentVect);
+}
+
+void XMLreader::mainProcessorIni( std::vector<TiXmlNode*> pParentVect )
+{
+    std::map<plint, TiXmlNode*> parents;
+    for (pluint iParent=0; iParent<pParentVect.size(); ++iParent) {
+        PLB_PRECONDITION( pParentVect[iParent]->Type()==TiXmlNode::DOCUMENT ||
+                          pParentVect[iParent]->Type()==TiXmlNode::ELEMENT );
+
+        TiXmlElement* pParentElement = pParentVect[iParent]->ToElement();
+        plint id=0;
+        if (pParentElement) {
+            const char* attribute = pParentElement->Attribute("id");
+            if (attribute) {
+                std::stringstream attributestr(attribute);
+                attributestr >> id;
+            }
+        }
+        parents[id] = pParentVect[iParent];
+    }
+
+    plint numId = (plint)parents.size();
+    global::mpi().bCast(&numId, 1);
+
+    std::map<plint, TiXmlNode*>::iterator it = parents.begin();
+    name = it->second->ValueStr();
+    global::mpi().bCast(name);
+
+    for (; it != parents.end(); ++it) {
+        plint id = it->first;
+        global::mpi().bCast(&id, 1);
+
+        TiXmlNode* pParent = it->second;
+        Data& data = data_map[id];
+        data.text="";
+
+        typedef std::map<std::string, std::vector<TiXmlNode*> > ChildMap;
+        ChildMap childMap;
+        TiXmlNode* pChild;
+        for ( pChild = pParent->FirstChild(); pChild != 0; pChild = pChild->NextSibling()) 
+        {
+            int type = pChild->Type();
+            if ( type==TiXmlNode::ELEMENT ) {
+                std::string name(pChild->Value());
+                childMap[name].push_back(pChild);
+            }
+            else if ( type==TiXmlNode::TEXT ) {
+                data.text = pChild->ToText()->ValueStr();
+            }
+        }
+        global::mpi().bCast(data.text);
+        plint numChildren = (plint) childMap.size();
+        global::mpi().bCast(&numChildren, 1);
+
+        for (ChildMap::iterator it = childMap.begin(); it != childMap.end(); ++it) {
+            std::vector<TiXmlNode*> pChildVect = it->second;
+            data.children.push_back( new XMLreader( pChildVect ) );
+        }
+    }
+}
+
+void XMLreader::slaveProcessorIni()
+{
+    plint numId = 0;
+    global::mpi().bCast(&numId, 1);
+    global::mpi().bCast(name);
+
+    for (plint iId=0; iId<numId; ++iId) {
+        plint id=0;
+        global::mpi().bCast(&id, 1);
+        Data& data = data_map[id];
+        global::mpi().bCast(data.text);
+        plint numChildren=0;
+        global::mpi().bCast(&numChildren, 1);
+
+        for(plint iChild=0; iChild<numChildren; ++iChild) {
+            std::vector<TiXmlNode*> noParam;
+            data.children.push_back( new XMLreader(noParam) );
+        }
+    }
+}
+
+XMLreader::XMLreader() {
+    name = "XML node not found";
+}
+
+XMLreader::~XMLreader() {
+    std::map<plint,Data>::iterator it = data_map.begin();
+    for (; it != data_map.end(); ++it) {
+        std::vector<XMLreader*>& children = it->second.children;
+        for (pluint iNode=0; iNode<children.size(); ++iNode) {
+            delete children[iNode];
+            children[iNode] = 0;
+        }
+    }
+}
+
+void XMLreader::print(int indent) const {
+    std::string indentStr(indent, ' ');
+    pcout << indentStr << "[" << name << "]" << std::endl;
+    std::string text = getFirstText();
+    if (!text.empty()) {
+        pcout << indentStr << "  " << text << std::endl;
+    }
+    std::vector<XMLreader*> const& children = data_map.begin()->second.children;
+    for (pluint iNode=0; iNode<children.size(); ++iNode) {
+        children[iNode]->print(indent+2);
+    }
+}
+
+XMLreaderProxy XMLreader::operator[] (std::string name) const
+{
+    Data const& data = data_map.begin()->second;
+    for (pluint iNode=0; iNode<data.children.size(); ++iNode) {
+        if (data.children[iNode]->name == name) {
+            return XMLreaderProxy(data.children[iNode]);
+        }
+    }
+    plbIOError( std::string("Element ")+name+std::string(" not found in XML file.") );
+    return XMLreaderProxy(0);
+}
+
+XMLreaderProxy XMLreader::getElement(std::string name, plint id) const {
+    std::map<plint,Data>::const_iterator it = data_map.find(id);
+    if (it==data_map.end()) {
+        std::stringstream idStr;
+        idStr << id;
+        plbIOError (
+                std::string("Element with id ") +
+                idStr.str() + std::string(" does not exist") );
+    }
+    std::vector<XMLreader*> const& children = it->second.children;
+    for (pluint iNode=0; iNode<children.size(); ++iNode) {
+        if (children[iNode]->name == name) {
+            return XMLreaderProxy(children[iNode]);
+        }
+    }
+    plbIOError( std::string("Element ")+name+std::string(" not found in XML file.") );
+    return XMLreaderProxy(0);
+}
+
+std::string XMLreader::getName() const {
+    return name;
+}
+
+std::string XMLreader::getText() const {
+    return data_map.begin()->second.text;
+}
+
+std::string XMLreader::getText(plint id) const {
+    std::map<plint,Data>::const_iterator it = data_map.find(id);
+    if (it != data_map.end()) {
+        return it->second.text;
+    }
+    else {
+        return "";
+    }
+}
+
+plint XMLreader::getFirstId() const {
+    return data_map.begin()->first;
+}
+
+std::string XMLreader::getFirstText() const {
+    return data_map.begin()->second.text;
+}
+
+bool XMLreader::idExists(plint id) const {
+    std::map<plint,Data>::const_iterator it = data_map.find(id);
+    if (it != data_map.end()) {
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+bool XMLreader::getNextId(plint& id) const {
+    std::map<plint,Data>::const_iterator it = data_map.find(id);
+    if (it != data_map.end()) {
+        ++it;
+        if (it != data_map.end()) {
+            id = it->first;
+            return true;
+        }
+    }
+    return false;
+}
+
+std::vector<XMLreader*> const& XMLreader::getChildren(plint id) const
+{
+    std::map<plint,Data>::const_iterator it = data_map.find(id);
+    if (it==data_map.end()) {
+        plbIOError(std::string("Cannot access id ")+util::val2str(id)+" in XML element " + name);
+    }
+    return it->second.children;
+}
+
+XMLreaderProxy::XMLreaderProxy(XMLreader const* reader_)
+    : reader(reader_)
+{
+    if (reader) {
+        id = reader->getFirstId();
+    }
+    else {
+        id = 0;
+    }
+}
+
+XMLreaderProxy::XMLreaderProxy(XMLreader const* reader_, plint id_)
+    : reader(reader_),
+      id(id_)
+{ }
+
+XMLreaderProxy XMLreaderProxy::operator[] (std::string name) const
+{
+    if (!reader) {
+        plbIOError(std::string("Cannot read value from XML element ") + name);
+    }
+    return reader->getElement(name, id);
+}
+
+XMLreaderProxy XMLreaderProxy::operator[] (plint newId) const {
+    if (!reader) {
+        plbIOError(std::string("Cannot read value from XML element"));
+    }
+    if (!reader->idExists(newId)) {
+        std::stringstream newIdStr;
+        newIdStr << newId;
+        plbIOError (
+                std::string("Id ") + newIdStr.str() +
+                std::string(" does not exist in XML element") );
+    }
+    return XMLreaderProxy(reader, newId);
+}
+
+bool XMLreaderProxy::isValid() const {
+    return reader;
+}
+
+plint XMLreaderProxy::getId() const {
+    return id;
+}
+
+XMLreaderProxy XMLreaderProxy::iterId() const {
+    if (!reader) {
+        plbIOError(std::string("Use of invalid XML element"));
+    }
+    plint newId = id;
+    if (reader->getNextId(newId)) {
+        return XMLreaderProxy(reader, newId);
+    }
+    else {
+        return XMLreaderProxy(0);
+    }
+}
+
+std::string XMLreaderProxy::getName() const {
+    if (!reader) {
+        plbIOError(std::string("Cannot read value from XML element "));
+    }
+    return reader->getName();
+}
+
+std::vector<XMLreader*> const& XMLreaderProxy::getChildren() const {
+    if (!reader) {
+        plbIOError(std::string("Cannot read value from XML element "));
+    }
+    return reader->getChildren(id);
+}
+
+
+XMLwriter::XMLwriter()
+    : isDocument(true),
+      currentId(0)
+{ }
+
+XMLwriter::~XMLwriter() {
+    std::map<plint,Data>::iterator it = data_map.begin();
+    for (; it != data_map.end(); ++it) {
+        std::vector<XMLwriter*>& children = it->second.children;
+        for (pluint iNode=0; iNode<children.size(); ++iNode) {
+            delete children[iNode];
+        }
+    }
+}
+
+XMLwriter::XMLwriter(std::string name_)
+    : isDocument(false),
+      name(name_),
+      currentId(0)
+{ }
+
+void XMLwriter::setString(std::string const& value)
+{
+    data_map[currentId].text = value;
+}
+
+
+XMLwriter& XMLwriter::operator[] (std::string name) {
+    std::vector<XMLwriter*>& children = data_map[currentId].children;
+    // If node already exists, simply return it.
+    for (pluint iNode=0; iNode<data_map[currentId].children.size(); ++iNode) {
+        if (data_map[currentId].children[iNode]->name == name) {
+            return *children[iNode];
+        }
+    }
+    // Else, create and return it.
+    children.push_back(new XMLwriter(name));
+    return *children.back();
+}
+
+XMLwriter& XMLwriter::operator[] (plint id) {
+    currentId = id;
+    return *this;
+}
+
+void XMLwriter::print(std::string fName) const {
+    plb_ofstream ofile(fName.c_str());
+    plbIOError( !ofile.is_open(), std::string("Could not open file ") + fName
+                                  + std::string(" for write access") );
+    toOutputStream(ofile);
+}
+
+std::string XMLwriter::sprint()
+{
+    std::stringstream a;
+    toOutputStream_parrallel(a);
+    return a.str();
+}
+
+
+}  // namespace plb
diff --git a/src/libraryInterfaces/TINYXML_xmlIO.h b/src/libraryInterfaces/TINYXML_xmlIO.h
index 9608415..4e899d4 100644
--- a/src/libraryInterfaces/TINYXML_xmlIO.h
+++ b/src/libraryInterfaces/TINYXML_xmlIO.h
@@ -1,139 +1,140 @@
-/* This file is part of the Palabos library.
-*
-* The Palabos softare is developed since 2011 by FlowKit-Numeca Group Sarl
-* (Switzerland) and the University of Geneva (Switzerland), which jointly
-* own the IP rights for most of the code base. Since October 2019, the
-* Palabos project is maintained by the University of Geneva and accepts
-* source code contributions from the community.
-*
-* Contact:
-* Jonas Latt
-* Computer Science Department
-* University of Geneva
-* 7 Route de Drize
-* 1227 Carouge, Switzerland
-* jonas.latt@unige.ch
-*
-* The most recent release of Palabos can be downloaded at
-* <https://palabos.unige.ch/>
-*
-* The library Palabos is free software: you can redistribute it and/or
-* modify it under the terms of the GNU Affero General Public License as
-* published by the Free Software Foundation, either version 3 of the
-* License, or (at your option) any later version.
-*
-* The library is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU Affero General Public License for more details.
-*
-* You should have received a copy of the GNU Affero General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/** \file
- * Input/Output in XML format -- header file.
- */
-
-#ifndef XML_IO_H
-#define XML_IO_H
-
-#include <string>
-#include <vector>
-#include <map>
-#include "tinyxml/tinyxml.h"
-#include "core/array.h"
-
-namespace plb {
-
-class XMLreaderProxy;
-
-class XMLreader {
-public:
-    XMLreader();
-    XMLreader( std::string fName );
-    void XMLreader_parse_from_string( const char *raw_xml);
-    XMLreader( std::vector<TiXmlNode*> pParentVect );
-    ~XMLreader();
-    void print(int indent) const;
-    XMLreaderProxy operator[] (std::string name) const;
-    XMLreaderProxy getElement(std::string name, plint id) const;
-    std::string getName() const;
-    std::string getText() const;
-    std::string getText(plint id) const;
-    plint getFirstId() const;
-    std::string getFirstText() const;
-    bool idExists(plint id) const;
-    bool getNextId(plint& id) const;
-    std::vector<XMLreader*> const& getChildren(plint id) const;
-private:
-    void mainProcessorIni(TiXmlNode* pParent);
-    void mainProcessorIni(std::vector<TiXmlNode*> pParentVect);
-    void slaveProcessorIni();
-
-private:
-    struct Data {
-        std::string text;
-        std::vector<XMLreader*> children;
-    };
-private:
-    std::string name;
-    std::map<plint,Data> data_map;
-    static XMLreader notFound;
-};
-
-class XMLreaderProxy {
-public:
-    XMLreaderProxy(XMLreader const* reader_);
-    XMLreaderProxy(XMLreader const* reader_, plint id_);
-    template <typename T> void read(T& values) const;
-    template <typename T> bool readNoThrow(T& values) const;
-    template <typename T> void read(std::vector<T>& values) const;
-    template <typename T> bool readNoThrow(std::vector<T>& values) const;
-    template <typename T, plint N> void read(Array<T,N>& values) const;
-    template <typename T, plint N> bool readNoThrow(Array<T,N>& values) const;
-    XMLreaderProxy operator[] (std::string name) const;
-    XMLreaderProxy operator[] (plint newId) const;
-    bool isValid() const;
-    plint getId() const;
-    XMLreaderProxy iterId() const;
-    std::string getName() const;
-    std::vector<XMLreader*> const& getChildren() const;
-private:
-    XMLreader const* reader;
-    plint id;
-};
-
-class XMLwriter {
-public:
-    XMLwriter();
-    ~XMLwriter();
-    template<typename T> void set(T const& value, plint precision=-1);
-    void setString(std::string const& value);
-    template<typename T> void set(std::vector<T> const& values, plint precision=-1);
-    template<typename T, int N> void set(Array<T,N> const& values, plint precision=-1);
-    XMLwriter& operator[] (std::string name);
-    XMLwriter& operator[] (plint id);
-    template<typename ostrT>
-    void toOutputStream_parrallel(ostrT& ostr, int indent=0) const;
-    template<typename ostrT>
-    void toOutputStream(ostrT& ostr, int indent=0) const;
-    void print(std::string fName) const;
-    std::string sprint();
-private:
-    XMLwriter( std::string name_ );
-private:
-    struct Data {
-        std::string text;
-        std::vector<XMLwriter*> children;
-    };
-private: 
-    bool isDocument;
-    std::string name;
-    std::map<plint,Data> data_map;
-    plint currentId;
-};
-
-}  // namespace plb
-
-#endif  // XML_IO_H
+/* This file is part of the Palabos library.
+*
+* The Palabos softare is developed since 2011 by FlowKit-Numeca Group Sarl
+* (Switzerland) and the University of Geneva (Switzerland), which jointly
+* own the IP rights for most of the code base. Since October 2019, the
+* Palabos project is maintained by the University of Geneva and accepts
+* source code contributions from the community.
+*
+* Contact:
+* Jonas Latt
+* Computer Science Department
+* University of Geneva
+* 7 Route de Drize
+* 1227 Carouge, Switzerland
+* jonas.latt@unige.ch
+*
+* The most recent release of Palabos can be downloaded at
+* <https://palabos.unige.ch/>
+*
+* The library Palabos is free software: you can redistribute it and/or
+* modify it under the terms of the GNU Affero General Public License as
+* published by the Free Software Foundation, either version 3 of the
+* License, or (at your option) any later version.
+*
+* The library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Affero General Public License for more details.
+*
+* You should have received a copy of the GNU Affero General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/** \file
+ * Input/Output in XML format -- header file.
+ */
+
+#ifndef XML_IO_H
+#define XML_IO_H
+
+#include <string>
+#include <vector>
+#include <map>
+#include "tinyxml/tinyxml.h"
+#include "core/array.h"
+
+namespace plb {
+
+class XMLreaderProxy;
+
+class XMLreader {
+public:
+    XMLreader();
+    XMLreader( std::string fName );
+    void XMLreader_parse_from_string( const char *raw_xml);
+    XMLreader( std::vector<TiXmlNode*> pParentVect );
+    ~XMLreader();
+    void print(int indent) const;
+    XMLreaderProxy operator[] (std::string name) const;
+    XMLreaderProxy getElement(std::string name, plint id) const;
+    std::string getName() const;
+    std::string getText() const;
+    std::string getText(plint id) const;
+    plint getFirstId() const;
+    std::string getFirstText() const;
+    bool idExists(plint id) const;
+    bool getNextId(plint& id) const;
+    std::vector<XMLreader*> const& getChildren(plint id) const;
+private:
+    void mainProcessorIni(TiXmlNode* pParent);
+    void mainProcessorIni(std::vector<TiXmlNode*> pParentVect);
+    void slaveProcessorIni();
+
+private:
+    struct Data {
+        std::string text;
+        std::vector<XMLreader*> children;
+    };
+private:
+    std::string name;
+    std::map<plint,Data> data_map;
+    static XMLreader notFound;
+};
+
+class XMLreaderProxy {
+public:
+    XMLreaderProxy(XMLreader const* reader_);
+    XMLreaderProxy(XMLreader const* reader_, plint id_);
+    template <typename T> void read(T& values) const;
+    template <typename T> T read() const;
+    template <typename T> bool readNoThrow(T& values) const;
+    template <typename T> void read(std::vector<T>& values) const;
+    template <typename T> bool readNoThrow(std::vector<T>& values) const;
+    template <typename T, plint N> void read(Array<T,N>& values) const;
+    template <typename T, plint N> bool readNoThrow(Array<T,N>& values) const;
+    XMLreaderProxy operator[] (std::string name) const;
+    XMLreaderProxy operator[] (plint newId) const;
+    bool isValid() const;
+    plint getId() const;
+    XMLreaderProxy iterId() const;
+    std::string getName() const;
+    std::vector<XMLreader*> const& getChildren() const;
+private:
+    XMLreader const* reader;
+    plint id;
+};
+
+class XMLwriter {
+public:
+    XMLwriter();
+    ~XMLwriter();
+    template<typename T> void set(T const& value, plint precision=-1);
+    void setString(std::string const& value);
+    template<typename T> void set(std::vector<T> const& values, plint precision=-1);
+    template<typename T, int N> void set(Array<T,N> const& values, plint precision=-1);
+    XMLwriter& operator[] (std::string name);
+    XMLwriter& operator[] (plint id);
+    template<typename ostrT>
+    void toOutputStream_parrallel(ostrT& ostr, int indent=0) const;
+    template<typename ostrT>
+    void toOutputStream(ostrT& ostr, int indent=0) const;
+    void print(std::string fName) const;
+    std::string sprint();
+private:
+    XMLwriter( std::string name_ );
+private:
+    struct Data {
+        std::string text;
+        std::vector<XMLwriter*> children;
+    };
+private: 
+    bool isDocument;
+    std::string name;
+    std::map<plint,Data> data_map;
+    plint currentId;
+};
+
+}  // namespace plb
+
+#endif  // XML_IO_H
diff --git a/src/libraryInterfaces/TINYXML_xmlIO.hh b/src/libraryInterfaces/TINYXML_xmlIO.hh
index 184d917..0fe9d58 100644
--- a/src/libraryInterfaces/TINYXML_xmlIO.hh
+++ b/src/libraryInterfaces/TINYXML_xmlIO.hh
@@ -1,354 +1,367 @@
-/* This file is part of the Palabos library.
- *
- * Copyright (C) 2011-2017 FlowKit Sarl
- * Route d'Oron 2
- * 1010 Lausanne, Switzerland
- * E-mail contact: contact@flowkit.com
- *
- * The most recent release of Palabos can be downloaded at 
- * <http://www.palabos.org/>
- *
- * The library Palabos is free software: you can redistribute it and/or
- * modify it under the terms of the GNU Affero General Public License as
- * published by the Free Software Foundation, either version 3 of the
- * License, or (at your option) any later version.
- *
- * The library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/** \file
- * Input/Output in XML format -- generic code.
- */
-
-#ifndef XML_IO_HH
-#define XML_IO_HH
-
-#include "libraryInterfaces/TINYXML_xmlIO.h"
-#include "core/runTimeDiagnostics.h"
-#include "core/globalDefs.h"
-#include "core/util.h"
-#include "parallelism/mpiManager.h"
-#include "io/parallelIO.h"
-#include <typeinfo>
-#include <cctype>
-#include <iomanip>
-
-namespace plb {
-
-template <typename T>
-void XMLreaderProxy::read(T& value) const {
-    if (!reader) return;
-    std::stringstream valueStr(reader->getText(id));
-    T tmp = T();
-    if (!(valueStr>>tmp)) {
-        plbIOError(std::string("Cannot read value from XML element ") + reader->getName());
-    }
-    value = tmp;
-}
-
-template <>
-inline void XMLreaderProxy::read<bool>(bool& value) const {
-    if (!reader) return;
-    std::stringstream valueStr(reader->getText(id));
-    std::string word;
-    valueStr >> word;
-    // Transform to lower-case, so that "true" and "false" are case-insensitive.
-    word = util::tolower(word);
-    if (word=="true") {
-        value = true;
-    }
-    else if (word=="false") {
-        value=false;
-    }
-    else {
-        plbIOError(std::string("Cannot read boolean value from XML element ") + reader->getName());
-    }
-}
-
-template <>
-inline void XMLreaderProxy::read<std::string>(std::string& entry) const {
-    if (!reader) return;
-    entry = reader->getText(id);
-}
-
-template <typename T>
-bool XMLreaderProxy::readNoThrow(T& value) const {
-    if (!reader) return false;
-    std::stringstream valueStr(reader->getText(id));
-    T tmp = T();
-    if (!(valueStr >> tmp)) {
-        return false;
-    }
-    value = tmp;
-    return true;
-}
-
-template <>
-inline bool XMLreaderProxy::readNoThrow<bool>(bool& value) const {
-    if (!reader) return false;
-    std::stringstream valueStr(reader->getText(id));
-    std::string word;
-    valueStr >> word;
-    // Transform to lower-case, so that "true" and "false" are case-insensitive.
-    word = util::tolower(word);
-    if (word=="true") {
-        value = true;
-        return true;
-    }
-    else if (word=="false") {
-        value=false;
-        return true;
-    }
-    return false;
-}
-
-template <>
-inline bool XMLreaderProxy::readNoThrow<std::string>(std::string& entry) const {
-    if (!reader) return false;
-    entry = reader->getText(id);
-    return true;
-}
-
-template <typename T>
-void XMLreaderProxy::read(std::vector<T>& values) const {
-    if (!reader) return;
-    std::stringstream multiValueStr(reader->getText(id));
-    std::string word;
-    std::vector<T> tmp(values);
-    while (multiValueStr>>word) {
-        std::stringstream valueStr(word);
-        T value;
-        if (!(valueStr >> value)) {
-            plbIOError(std::string("Cannot read value array from XML element ") + reader->getName());
-        }
-        tmp.push_back(value);
-    }
-    values.swap(tmp);
-}
-
-template <>
-inline void XMLreaderProxy::read<bool>(std::vector<bool>& values) const {
-    if (!reader) return;
-    std::stringstream multiValueStr(reader->getText(id));
-    std::string word;
-    std::vector<bool> tmp(values);
-    while (multiValueStr>>word) {
-        bool value = false;
-        word = util::tolower(word);
-        if (word=="true") {
-            value = true;
-        }
-        else if (word=="false") {
-            value=false;
-        }
-        else {
-            plbIOError(std::string("Cannot read boolean value from XML element ") + reader->getName());
-        }
-        tmp.push_back(value);
-    }
-    values.swap(tmp);
-}
-
-template <typename T>
-bool XMLreaderProxy::readNoThrow(std::vector<T>& values) const {
-    if (!reader) return false;
-    std::stringstream multiValueStr(reader->getText(id));
-    std::string word;
-    std::vector<T> tmp(values);
-    while (multiValueStr>>word) {
-        std::stringstream valueStr(word);
-        T value;
-        if (!(valueStr >> value)) {
-            return false;
-        }
-        tmp.push_back(value);
-    }
-    values.swap(tmp);
-    return true;
-}
-
-template <typename T, plint N>
-void XMLreaderProxy::read(Array<T,N>& values) const {
-    if (!reader) return;
-    std::stringstream multiValueStr(reader->getText(id));
-    std::string word;
-    values.resetToZero();
-    plint i=0;
-    while (multiValueStr>>word && i<N) {
-        std::stringstream valueStr(word);
-        T value;
-        if (!(valueStr >> value)) {
-            plbIOError(std::string("Cannot read value array from XML element ") + reader->getName());
-        }
-        values[i] = value;
-        ++i;
-    }
-}
-
-template <typename T, plint N>
-bool XMLreaderProxy::readNoThrow(Array<T,N>& values) const {
-    if (!reader) return false;
-    std::stringstream multiValueStr(reader->getText(id));
-    std::string word;
-    plint i=0;
-    while (multiValueStr>>word && i<N) {
-        std::stringstream valueStr(word);
-        T value;
-        if (!(valueStr >> value)) {
-            return false;
-        }
-        values[i] = value;
-        ++i;
-    }
-    return true;
-}
-
-template<typename T> void XMLwriter::set(T const& value, plint precision)
-{
-    std::stringstream valuestr;
-    if (precision >= 0) {
-        valuestr << std::setprecision(precision);
-    }
-    valuestr << value;
-    valuestr >> data_map[currentId].text;
-}
-
-template<typename T> void XMLwriter::set(std::vector<T> const& values, plint precision)
-{
-    std::stringstream valuestr;
-    if (precision >= 0) {
-        valuestr << std::setprecision(precision);
-    }
-    for (pluint i=0; i<values.size(); ++i) {
-        if (i != 0) {
-            valuestr << " ";
-        }
-        valuestr << values[i];
-    }
-    data_map[currentId].text = valuestr.str();
-}
-
-template<typename T, int N> void XMLwriter::set(Array<T,N> const& values, plint precision)
-{
-    std::stringstream valuestr;
-    if (precision >= 0) {
-        valuestr << std::setprecision(precision);
-    }
-    for (pluint i=0; i<N; ++i) {
-        if (i != 0) {
-            valuestr << " ";
-        }
-        valuestr << values[i];
-    }
-    data_map[currentId].text = valuestr.str();
-}
-
-template<> inline void XMLwriter::set<bool>(bool const& value, plint precision)
-{
-    if (value) {
-        data_map[currentId].text = "True";
-    }
-    else {
-        data_map[currentId].text = "False";
-    }
-}
-
-template<typename ostrT>
-void XMLwriter::toOutputStream_parrallel(ostrT& ostr, int indent) const {
-
-    if (data_map.empty()) return;
-    if (isDocument) {
-        ostr << "<?xml version=\"1.0\" ?>\n";
-        std::vector<XMLwriter*> const& children = data_map.begin()->second.children;
-        for (pluint iNode=0; iNode<children.size(); ++iNode) {
-            children[iNode]->toOutputStream_parrallel(ostr);
-        }
-    } else {
-        std::map<plint,Data>::const_iterator it = data_map.begin();
-        for (; it != data_map.end(); ++it) {
-            std::vector<XMLwriter*> const& children = it->second.children;
-            std::string const& text = it->second.text;
-            std::string indentStr(indent, ' ');
-            ostr << indentStr << "<" << name;
-            if (data_map.size()>1 || it->first!=0) {
-                ostr << " id=\"" << it->first << "\"";
-            }
-            if (children.empty()) {
-                ostr << ">";
-            } else {
-                ostr << ">\n";
-            }
-            if (!text.empty()) {
-                if (children.empty()) {
-                    ostr << " " << text << " ";
-                } else {
-                    ostr << indentStr << "    " << text << "\n";
-                }
-            }
-            for (pluint iNode=0; iNode<children.size(); ++iNode) {
-                children[iNode]->toOutputStream_parrallel(ostr, indent+4);
-            }
-            if (!children.empty()) {
-                ostr << indentStr;
-            }
-            ostr << "</" << name << ">\n";
-        }
-    }
-}
-
-template<typename ostrT>
-void XMLwriter::toOutputStream(ostrT& ostr, int indent) const {
-    if (!global::mpi().isMainProcessor()) return;
-    if (data_map.empty()) return;
-
-    if (isDocument) {
-        ostr << "<?xml version=\"1.0\" ?>\n";
-        std::vector<XMLwriter*> const& children = data_map.begin()->second.children;
-        for (pluint iNode=0; iNode<children.size(); ++iNode) {
-            children[iNode]->toOutputStream(ostr);
-        }
-    }
-    else {
-        std::map<plint,Data>::const_iterator it = data_map.begin();
-        for (; it != data_map.end(); ++it) {
-            std::vector<XMLwriter*> const& children = it->second.children;
-            std::string const& text = it->second.text;
-            std::string indentStr(indent, ' ');
-            ostr << indentStr << "<" << name;
-            if (data_map.size()>1 || it->first!=0) {
-                ostr << " id=\"" << it->first << "\"";
-            }
-            if (children.empty()) {
-                ostr << ">";
-            }
-            else {
-                ostr << ">\n";
-            }
-            if (!text.empty()) {
-                if (children.empty()) {
-                    ostr << " " << text << " ";
-                }
-                else {
-                    ostr << indentStr << "    " << text << "\n";
-                }
-            }
-            for (pluint iNode=0; iNode<children.size(); ++iNode) {
-                children[iNode]->toOutputStream(ostr, indent+4);
-            }
-            if (!children.empty()) {
-                ostr << indentStr;
-            }
-            ostr << "</" << name << ">\n";
-        }
-    }
-}
-
-}  // namespace plb
-
-#endif  // XML_IO_HH
+/* This file is part of the Palabos library.
+ *
+ * Copyright (C) 2011-2017 FlowKit Sarl
+ * Route d'Oron 2
+ * 1010 Lausanne, Switzerland
+ * E-mail contact: contact@flowkit.com
+ *
+ * The most recent release of Palabos can be downloaded at 
+ * <http://www.palabos.org/>
+ *
+ * The library Palabos is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * The library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/** \file
+ * Input/Output in XML format -- generic code.
+ */
+
+#ifndef XML_IO_HH
+#define XML_IO_HH
+
+#include "libraryInterfaces/TINYXML_xmlIO.h"
+#include "core/runTimeDiagnostics.h"
+#include "core/globalDefs.h"
+#include "core/util.h"
+#include "parallelism/mpiManager.h"
+#include "io/parallelIO.h"
+#include <typeinfo>
+#include <cctype>
+#include <iomanip>
+
+namespace plb {
+
+template <typename T>
+void XMLreaderProxy::read(T& value) const {
+    if (!reader) return;
+    std::stringstream valueStr(reader->getText(id));
+    T tmp = T();
+    if (!(valueStr>>tmp)) {
+        plbIOError(std::string("Cannot read value from XML element ") + reader->getName());
+    }
+    value = tmp;
+}
+
+template <typename T>
+T XMLreaderProxy::read() const {
+    if (!reader) {
+        plbIOError(std::string("XMLreaderProxy has no reader"));
+    }
+    std::stringstream valueStr(reader->getText(id));
+    T tmp = T();
+    if (!(valueStr>>tmp)) {
+        plbIOError(std::string("Cannot read value from XML element ") + reader->getName());
+    }
+    return tmp;
+}
+
+template <>
+inline void XMLreaderProxy::read<bool>(bool& value) const {
+    if (!reader) return;
+    std::stringstream valueStr(reader->getText(id));
+    std::string word;
+    valueStr >> word;
+    // Transform to lower-case, so that "true" and "false" are case-insensitive.
+    word = util::tolower(word);
+    if (word=="true") {
+        value = true;
+    }
+    else if (word=="false") {
+        value=false;
+    }
+    else {
+        plbIOError(std::string("Cannot read boolean value from XML element ") + reader->getName());
+    }
+}
+
+template <>
+inline void XMLreaderProxy::read<std::string>(std::string& entry) const {
+    if (!reader) return;
+    entry = reader->getText(id);
+}
+
+template <typename T>
+bool XMLreaderProxy::readNoThrow(T& value) const {
+    if (!reader) return false;
+    std::stringstream valueStr(reader->getText(id));
+    T tmp = T();
+    if (!(valueStr >> tmp)) {
+        return false;
+    }
+    value = tmp;
+    return true;
+}
+
+template <>
+inline bool XMLreaderProxy::readNoThrow<bool>(bool& value) const {
+    if (!reader) return false;
+    std::stringstream valueStr(reader->getText(id));
+    std::string word;
+    valueStr >> word;
+    // Transform to lower-case, so that "true" and "false" are case-insensitive.
+    word = util::tolower(word);
+    if (word=="true") {
+        value = true;
+        return true;
+    }
+    else if (word=="false") {
+        value=false;
+        return true;
+    }
+    return false;
+}
+
+template <>
+inline bool XMLreaderProxy::readNoThrow<std::string>(std::string& entry) const {
+    if (!reader) return false;
+    entry = reader->getText(id);
+    return true;
+}
+
+template <typename T>
+void XMLreaderProxy::read(std::vector<T>& values) const {
+    if (!reader) return;
+    std::stringstream multiValueStr(reader->getText(id));
+    std::string word;
+    std::vector<T> tmp(values);
+    while (multiValueStr>>word) {
+        std::stringstream valueStr(word);
+        T value;
+        if (!(valueStr >> value)) {
+            plbIOError(std::string("Cannot read value array from XML element ") + reader->getName());
+        }
+        tmp.push_back(value);
+    }
+    values.swap(tmp);
+}
+
+template <>
+inline void XMLreaderProxy::read<bool>(std::vector<bool>& values) const {
+    if (!reader) return;
+    std::stringstream multiValueStr(reader->getText(id));
+    std::string word;
+    std::vector<bool> tmp(values);
+    while (multiValueStr>>word) {
+        bool value = false;
+        word = util::tolower(word);
+        if (word=="true") {
+            value = true;
+        }
+        else if (word=="false") {
+            value=false;
+        }
+        else {
+            plbIOError(std::string("Cannot read boolean value from XML element ") + reader->getName());
+        }
+        tmp.push_back(value);
+    }
+    values.swap(tmp);
+}
+
+template <typename T>
+bool XMLreaderProxy::readNoThrow(std::vector<T>& values) const {
+    if (!reader) return false;
+    std::stringstream multiValueStr(reader->getText(id));
+    std::string word;
+    std::vector<T> tmp(values);
+    while (multiValueStr>>word) {
+        std::stringstream valueStr(word);
+        T value;
+        if (!(valueStr >> value)) {
+            return false;
+        }
+        tmp.push_back(value);
+    }
+    values.swap(tmp);
+    return true;
+}
+
+template <typename T, plint N>
+void XMLreaderProxy::read(Array<T,N>& values) const {
+    if (!reader) return;
+    std::stringstream multiValueStr(reader->getText(id));
+    std::string word;
+    values.resetToZero();
+    plint i=0;
+    while (multiValueStr>>word && i<N) {
+        std::stringstream valueStr(word);
+        T value;
+        if (!(valueStr >> value)) {
+            plbIOError(std::string("Cannot read value array from XML element ") + reader->getName());
+        }
+        values[i] = value;
+        ++i;
+    }
+}
+
+template <typename T, plint N>
+bool XMLreaderProxy::readNoThrow(Array<T,N>& values) const {
+    if (!reader) return false;
+    std::stringstream multiValueStr(reader->getText(id));
+    std::string word;
+    plint i=0;
+    while (multiValueStr>>word && i<N) {
+        std::stringstream valueStr(word);
+        T value;
+        if (!(valueStr >> value)) {
+            return false;
+        }
+        values[i] = value;
+        ++i;
+    }
+    return true;
+}
+
+template<typename T> void XMLwriter::set(T const& value, plint precision)
+{
+    std::stringstream valuestr;
+    if (precision >= 0) {
+        valuestr << std::setprecision(precision);
+    }
+    valuestr << value;
+    valuestr >> data_map[currentId].text;
+}
+
+template<typename T> void XMLwriter::set(std::vector<T> const& values, plint precision)
+{
+    std::stringstream valuestr;
+    if (precision >= 0) {
+        valuestr << std::setprecision(precision);
+    }
+    for (pluint i=0; i<values.size(); ++i) {
+        if (i != 0) {
+            valuestr << " ";
+        }
+        valuestr << values[i];
+    }
+    data_map[currentId].text = valuestr.str();
+}
+
+template<typename T, int N> void XMLwriter::set(Array<T,N> const& values, plint precision)
+{
+    std::stringstream valuestr;
+    if (precision >= 0) {
+        valuestr << std::setprecision(precision);
+    }
+    for (pluint i=0; i<N; ++i) {
+        if (i != 0) {
+            valuestr << " ";
+        }
+        valuestr << values[i];
+    }
+    data_map[currentId].text = valuestr.str();
+}
+
+template<> inline void XMLwriter::set<bool>(bool const& value, plint precision)
+{
+    if (value) {
+        data_map[currentId].text = "True";
+    }
+    else {
+        data_map[currentId].text = "False";
+    }
+}
+
+template<typename ostrT>
+void XMLwriter::toOutputStream_parrallel(ostrT& ostr, int indent) const {
+
+    if (data_map.empty()) return;
+    if (isDocument) {
+        ostr << "<?xml version=\"1.0\" ?>\n";
+        std::vector<XMLwriter*> const& children = data_map.begin()->second.children;
+        for (pluint iNode=0; iNode<children.size(); ++iNode) {
+            children[iNode]->toOutputStream_parrallel(ostr);
+        }
+    } else {
+        std::map<plint,Data>::const_iterator it = data_map.begin();
+        for (; it != data_map.end(); ++it) {
+            std::vector<XMLwriter*> const& children = it->second.children;
+            std::string const& text = it->second.text;
+            std::string indentStr(indent, ' ');
+            ostr << indentStr << "<" << name;
+            if (data_map.size()>1 || it->first!=0) {
+                ostr << " id=\"" << it->first << "\"";
+            }
+            if (children.empty()) {
+                ostr << ">";
+            } else {
+                ostr << ">\n";
+            }
+            if (!text.empty()) {
+                if (children.empty()) {
+                    ostr << " " << text << " ";
+                } else {
+                    ostr << indentStr << "    " << text << "\n";
+                }
+            }
+            for (pluint iNode=0; iNode<children.size(); ++iNode) {
+                children[iNode]->toOutputStream_parrallel(ostr, indent+4);
+            }
+            if (!children.empty()) {
+                ostr << indentStr;
+            }
+            ostr << "</" << name << ">\n";
+        }
+    }
+}
+
+template<typename ostrT>
+void XMLwriter::toOutputStream(ostrT& ostr, int indent) const {
+    if (!global::mpi().isMainProcessor()) return;
+    if (data_map.empty()) return;
+
+    if (isDocument) {
+        ostr << "<?xml version=\"1.0\" ?>\n";
+        std::vector<XMLwriter*> const& children = data_map.begin()->second.children;
+        for (pluint iNode=0; iNode<children.size(); ++iNode) {
+            children[iNode]->toOutputStream(ostr);
+        }
+    }
+    else {
+        std::map<plint,Data>::const_iterator it = data_map.begin();
+        for (; it != data_map.end(); ++it) {
+            std::vector<XMLwriter*> const& children = it->second.children;
+            std::string const& text = it->second.text;
+            std::string indentStr(indent, ' ');
+            ostr << indentStr << "<" << name;
+            if (data_map.size()>1 || it->first!=0) {
+                ostr << " id=\"" << it->first << "\"";
+            }
+            if (children.empty()) {
+                ostr << ">";
+            }
+            else {
+                ostr << ">\n";
+            }
+            if (!text.empty()) {
+                if (children.empty()) {
+                    ostr << " " << text << " ";
+                }
+                else {
+                    ostr << indentStr << "    " << text << "\n";
+                }
+            }
+            for (pluint iNode=0; iNode<children.size(); ++iNode) {
+                children[iNode]->toOutputStream(ostr, indent+4);
+            }
+            if (!children.empty()) {
+                ostr << indentStr;
+            }
+            ostr << "</" << name << ">\n";
+        }
+    }
+}
+
+}  // namespace plb
+
+#endif  // XML_IO_HH
diff --git a/src/multiBlock/localMultiBlockInfo3D.cpp b/src/multiBlock/localMultiBlockInfo3D.cpp
index 1ceb9d2..b39c648 100644
--- a/src/multiBlock/localMultiBlockInfo3D.cpp
+++ b/src/multiBlock/localMultiBlockInfo3D.cpp
@@ -149,8 +149,9 @@ void LocalMultiBlockInfo3D::computeAllPeriodicOverlaps (
         sparseBlock.getBulk(blockId, bulk);
         // Speed optimization: execute the test for periodicity
         //   only for bulk-domains which touch the bounding box.
+        //BUGFIXED to envelopewidth by HEMOCELL TEAM (victor)
         if (!contained (
-                    bulk.enlarge(1), sparseBlock.getBoundingBox() ) )
+                    bulk.enlarge(envelopeWidth), sparseBlock.getBoundingBox() ) )
         {
             computePeriodicOverlaps(sparseBlock, blockId);
         }
diff --git a/src/multiBlock/localMultiBlockInfo3D.h b/src/multiBlock/localMultiBlockInfo3D.h
index 4ca9752..58cbda8 100644
--- a/src/multiBlock/localMultiBlockInfo3D.h
+++ b/src/multiBlock/localMultiBlockInfo3D.h
@@ -138,6 +138,7 @@ private:
     /// Determine all blocks which are associated to the current MPI thread.
     void computeMyBlocks(SparseBlockStructure3D const& sparseBlock,
                          ThreadAttribution const& attribution);
+public:    
     /// Compute normal overlaps for all local blocks.
     void computeAllNormalOverlaps(SparseBlockStructure3D const& sparseBlock);
     /// Compute normal overlaps for one local block.
@@ -146,9 +147,11 @@ private:
     void computeAllPeriodicOverlaps(SparseBlockStructure3D const& sparseBlock);
     /// Compute periodic overlaps for one local block.
     void computePeriodicOverlaps(SparseBlockStructure3D const& sparseBlock, plint blockId);
-private:
+public:
     plint                          envelopeWidth;
+private:
     std::vector<plint>             myBlocks;
+public:
     std::vector<Overlap3D>         normalOverlaps;
     std::vector<PeriodicOverlap3D> periodicOverlaps;
     std::vector<PeriodicOverlap3D> periodicOverlapWithRemoteData;
diff --git a/src/multiBlock/multiBlock3D.cpp b/src/multiBlock/multiBlock3D.cpp
index 9e88c7f..8bb3481 100644
--- a/src/multiBlock/multiBlock3D.cpp
+++ b/src/multiBlock/multiBlock3D.cpp
@@ -259,7 +259,7 @@ MultiBlock3D::MultiBlock3D( MultiBlockManagement3D const& multiBlockManagement_,
       internalStatistics(),
       combinedStatistics(combinedStatistics_),
       statSubscriber(*this),
-      statisticsOn(true),
+      statisticsOn(false),
       periodicitySwitch(*this),
       internalModifT(modif::staticVariables)
 { 
@@ -274,7 +274,7 @@ MultiBlock3D::MultiBlock3D(plint nx, plint ny, plint nz, plint envelopeWidth)
       internalStatistics(),
       combinedStatistics(defaultMultiBlockPolicy3D().getCombinedStatistics()),
       statSubscriber(*this),
-      statisticsOn(true),
+      statisticsOn(false),
       periodicitySwitch(*this),
       internalModifT(modif::staticVariables)
 {
@@ -306,7 +306,7 @@ MultiBlock3D::MultiBlock3D(MultiBlock3D const& rhs, Box3D subDomain, bool crop)
       internalStatistics(),
       combinedStatistics(rhs.combinedStatistics->clone()),
       statSubscriber(*this),
-      statisticsOn(true),
+      statisticsOn(false),
       periodicitySwitch(*this),
       internalModifT(rhs.internalModifT)
 {
@@ -361,6 +361,10 @@ MultiBlockManagement3D const& MultiBlock3D::getMultiBlockManagement() const {
     return multiBlockManagement;
 }
 
+MultiBlockManagement3D & MultiBlock3D::getMultiBlockManagement() {
+    return multiBlockManagement;
+}
+
 void MultiBlock3D::setCoProcessors(std::map<plint,int> const& coProcessors) {
     multiBlockManagement.setCoProcessors(coProcessors);
 }
diff --git a/src/multiBlock/multiBlock3D.h b/src/multiBlock/multiBlock3D.h
index b3ccc0d..f57432e 100644
--- a/src/multiBlock/multiBlock3D.h
+++ b/src/multiBlock/multiBlock3D.h
@@ -161,6 +161,7 @@ public:
     std::vector<ProcessorStorage3D> const& getStoredProcessors() const;
 public:
     MultiBlockManagement3D const& getMultiBlockManagement() const;
+    MultiBlockManagement3D & getMultiBlockManagement();
     void setCoProcessors(std::map<plint,int> const& coProcessors);
     LocalMultiBlockInfo3D const& getLocalInfo() const;
     SparseBlockStructure3D const& getSparseBlockStructure() const;
diff --git a/src/multiBlock/multiBlockManagement3D.cpp b/src/multiBlock/multiBlockManagement3D.cpp
index c65b96f..222bc91 100644
--- a/src/multiBlock/multiBlockManagement3D.cpp
+++ b/src/multiBlock/multiBlockManagement3D.cpp
@@ -203,8 +203,17 @@ void MultiBlockManagement3D::setRefinementLevel(plint newLevel) {
 }
 
 void MultiBlockManagement3D::changeEnvelopeWidth(plint newEnvelopeWidth) {
-    envelopeWidth = newEnvelopeWidth;
-    localInfo = LocalMultiBlockInfo3D(sparseBlock, getThreadAttribution(), envelopeWidth);
+    localInfo.envelopeWidth = newEnvelopeWidth;
+
+    localInfo.normalOverlaps.clear();
+    localInfo.periodicOverlapWithRemoteData.clear();
+    localInfo.periodicOverlaps.clear();
+
+    localInfo.computeAllNormalOverlaps(sparseBlock);
+    localInfo.computeAllPeriodicOverlaps(sparseBlock);
+    
+    std::sort(localInfo.normalOverlaps.begin(), localInfo.normalOverlaps.end());
+    std::sort(localInfo.periodicOverlaps.begin(), localInfo.periodicOverlaps.end());
 }
 
 bool MultiBlockManagement3D::equivalentTo(MultiBlockManagement3D const& rhs) const {
diff --git a/src/multiBlock/multiDataField3D.hh b/src/multiBlock/multiDataField3D.hh
index 13c9a1b..f56e0f7 100644
--- a/src/multiBlock/multiDataField3D.hh
+++ b/src/multiBlock/multiDataField3D.hh
@@ -813,9 +813,11 @@ void MultiNTensorField3D<T>::reset() {
 
 template<typename T>
 void MultiNTensorField3D<T>::allocateFields() {
-    std::vector<T> iniVal(this->getNdim());
-    std::fill(iniVal.begin(), iniVal.end(), T());
-    allocateFields(&iniVal[0]);
+    //std::vector<T> iniVal(this->getNdim());
+    //std::fill(iniVal.begin(), iniVal.end(), T());
+  const T * iniVal = new T[this->getNdim()];
+    allocateFields(iniVal);
+    delete[] iniVal;
 }
 
 template<typename T>
diff --git a/src/multiBlock/sparseBlockStructure3D.cpp b/src/multiBlock/sparseBlockStructure3D.cpp
index c26e79d..5e38a3e 100644
--- a/src/multiBlock/sparseBlockStructure3D.cpp
+++ b/src/multiBlock/sparseBlockStructure3D.cpp
@@ -87,6 +87,20 @@ SparseBlockStructure3D::SparseBlockStructure3D (
                                                / (double)rhs.boundingBox.getNz() );
     if (gridNz < 1) gridNz = 1;
 }
+SparseBlockStructure3D * SparseBlockStructure3D::clone() const{
+  SparseBlockStructure3D * newBlock = new SparseBlockStructure3D(1,1,1);
+  newBlock->boundingBox = boundingBox;
+  newBlock->bulks = bulks;
+  newBlock->uniqueBulks = uniqueBulks;
+  newBlock->grid = grid;
+  newBlock->gridLx = gridLx;
+  newBlock->gridLy = gridLy;
+  newBlock->gridLz = gridLz;
+  newBlock->gridNx = gridNx;
+  newBlock->gridNy = gridNy;
+  newBlock->gridNz = gridNz;
+  return newBlock;
+}
 
 void SparseBlockStructure3D::addBlock(Box3D const& bulk, plint blockId) 
 {
@@ -118,7 +132,7 @@ void SparseBlockStructure3D::removeBlock(plint blockId) {
     }
 }
 
-bool SparseBlockStructure3D::exists(plint blockId) {
+bool SparseBlockStructure3D::exists(plint blockId) const {
     return bulks.find(blockId) != bulks.end();
 }
 
@@ -797,7 +811,6 @@ SparseBlockStructure3D alignDistribution3D (
     return newSparseBlock;
 }
 
-
 EuclideanIterator3D::EuclideanIterator3D(SparseBlockStructure3D const& sparseBlock_)
     : sparseBlock(sparseBlock_)
 { }
diff --git a/src/multiBlock/sparseBlockStructure3D.h b/src/multiBlock/sparseBlockStructure3D.h
index ca4837d..4d6632d 100644
--- a/src/multiBlock/sparseBlockStructure3D.h
+++ b/src/multiBlock/sparseBlockStructure3D.h
@@ -60,6 +60,8 @@ public:
                            plint gridNx_, plint gridNy_, plint gridNz_);
     /// Restrict an existing SparseBlockStructure3D to a sub-domain.
     SparseBlockStructure3D(SparseBlockStructure3D const& rhs, Box3D boundingBox_);
+    ///Clone the goddamned thing
+    SparseBlockStructure3D * clone() const;
     /// Add a new block to the sparse block-structure.
     void addBlock(Box3D const& bulk, Box3D const& uniqueBulk, plint blockId);
     /// Add a new block to the sparse block-structure; uniqueBulk = bulk.
@@ -67,7 +69,7 @@ public:
     /// Remove an existing block from the sparse block-structure.
     void removeBlock(plint blockId);
     /// Check if a block with the given ID already exists in the block-structure.
-    bool exists(plint blockId);
+    bool exists(plint blockId) const;
     /// Return 1 + the maximum block ID currently found in the structure.
     plint nextIncrementalId() const;
     /// Return outer bounding box.
diff --git a/src/offLattice/triangularSurfaceMesh.h b/src/offLattice/triangularSurfaceMesh.h
index 81586f9..8bb6c17 100644
--- a/src/offLattice/triangularSurfaceMesh.h
+++ b/src/offLattice/triangularSurfaceMesh.h
@@ -153,6 +153,12 @@ public:
     ///   3.] The third rotation is by an angle psi about the new z-axis.
     void rotate(T phi, T theta, T psi);
 
+    /// Rotate the surface mesh.
+    ///   Alternative method using axial rotations. 
+    ///   The subsequent rotations happen in the following order: around x, around y, around z.
+    ///   Angles are in radians.
+    void rotateXYZ(T alpha, T beta, T gamma);
+
     /// Smooth the surface mesh.
     ///   The triangular surface mesh is smoothed by using a spatial
     ///   averaging algorithm. Interior vertices are treated differently
diff --git a/src/offLattice/triangularSurfaceMesh.hh b/src/offLattice/triangularSurfaceMesh.hh
index 497f5eb..4603046 100644
--- a/src/offLattice/triangularSurfaceMesh.hh
+++ b/src/offLattice/triangularSurfaceMesh.hh
@@ -40,6 +40,7 @@
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
+#include <iomanip>
 #include "offLattice/triangularSurfaceMesh.h"
 #include "offLattice/triangleSet.h"
 #include "latticeBoltzmann/geometricOperationTemplates.h"
@@ -297,6 +298,82 @@ void TriangularSurfaceMesh<T>::rotate(T phi, T theta, T psi)
     }
 }
 
+template<typename T>
+void TriangularSurfaceMesh<T>::rotateXYZ(T alpha, T beta, T gamma)
+{
+    static const T pi = std::acos((T) -1.0);
+
+    PLB_ASSERT((theta > T() || util::fpequal(theta, T(), eps0)) &&
+               (theta < pi  || util::fpequal(theta, pi, eps0)));
+
+    // Rotation matrix around x axis (column-first)
+    T a[3][3];
+    a[0][0] =  (T) 1.0;
+    a[0][1] =  (T) 0.0;
+    a[0][2] =  (T) 0.0;
+    a[1][0] =  (T) 0.0;
+    a[1][1] =  std::cos(alpha);
+    a[1][2] =  std::sin(alpha);
+    a[2][0] =  (T) 0.0;
+    a[2][1] = -std::sin(alpha);
+    a[2][2] =  std::cos(alpha);
+
+    // Rotation matrix around y axis (column-first)
+    T b[3][3];
+    b[0][0] =  std::cos(beta);
+    b[0][1] =  (T) 0.0;
+    b[0][2] =  -std::sin(beta);
+    b[1][0] =  (T) 0.0;
+    b[1][1] =  (T) 1.0;
+    b[1][2] =  (T) 0.0;
+    b[2][0] =  std::sin(beta);
+    b[2][1] =  (T) 0.0;
+    b[2][2] =  std::cos(beta);
+
+    // Ry * Rx
+    T c[3][3];
+    for (int i = 0; i < 3; i++) {
+        for (int j = 0; j < 3; j++) {
+            c[i][j] = (T) 0.0;
+            for (int k = 0; k < 3; k++) {
+                c[i][j] += a[k][j]*b[i][k];
+            }
+        }
+    }
+
+    // Rotation matrix around z axis (column-first)
+    b[0][0] =  std::cos(gamma);
+    b[0][1] =  std::sin(gamma);
+    b[0][2] =  (T) 0.0;
+    b[1][0] = -std::sin(gamma);
+    b[1][1] =  std::cos(gamma);
+    b[1][2] =  (T) 0.0;
+    b[2][0] =  (T) 0.0;
+    b[2][1] =  (T) 0.0;
+    b[2][2] =  (T) 1.0;
+
+
+    // Rz * [Ry*Rx]
+    for (int i = 0; i < 3; i++) {
+        for (int j = 0; j < 3; j++) {
+            a[i][j] = (T) 0.0;
+            for (int k = 0; k < 3; k++) {
+                a[i][j] += c[k][j]*b[i][k];
+            }
+        }
+    }
+
+    for (plint iVertex = 0; iVertex < numVertices; iVertex++) {
+        Array<T,3> x = getVertex(iVertex);
+        for (int i = 0; i < 3; i++) {
+            getVertex(iVertex)[i] = (T) 0.0;
+            for (int j = 0; j < 3; j++) {
+                getVertex(iVertex)[i] += a[i][j]*x[j];
+            }
+        }
+    }
+}
+
 template<typename T>
 void TriangularSurfaceMesh<T>::smooth(plint maxiter, T relax, bool isMeasureWeighted)
 {
diff --git a/src/parallelism/parallelBlockCommunicator3D.cpp b/src/parallelism/parallelBlockCommunicator3D.cpp
index 4bc39c7..a5cc7c9 100644
--- a/src/parallelism/parallelBlockCommunicator3D.cpp
+++ b/src/parallelism/parallelBlockCommunicator3D.cpp
@@ -34,6 +34,8 @@
 /** \file
  * Helper classes for parallel 3D multiblock lattice -- generic implementation.
  */
+//For efficient c-style communication:
+#include "../../../core/hemoCellParticleDataTransfer.h"
 
 #include "parallelism/parallelBlockCommunicator3D.h"
 #include "multiBlock/multiBlock3D.h"
@@ -45,6 +47,7 @@
 #ifdef PLB_MPI_PARALLEL
 #include <mpi.h>
 #endif
+#include <numeric>
 
 namespace plb {
 
@@ -116,8 +119,11 @@ CommunicationStructure3D::CommunicationStructure3D (
 
     sendComm = SendPoolCommunicator(sendPool);
     recvComm = RecvPoolCommunicator(recvPool);
-}
+  }
 
+  CommunicationStructure3D::CommunicationStructure3D(const CommunicationStructure3D& rhs) {
+   *this = rhs;
+  }
 
 
 CommunicationPattern3D::CommunicationPattern3D (
@@ -241,6 +247,30 @@ void ParallelBlockCommunicator3D::duplicateOverlaps( MultiBlock3D& multiBlock,
     communicate(*communication, multiBlock, multiBlock, whichData);
 }
 
+void ParallelBlockCommunicator3D::duplicateOverlaps( MultiBlockManagement3D& multiBlockManagement,
+                                                     PeriodicitySwitch3D const& periodicity  ) const
+{
+
+    // Implement a caching mechanism for the communication structure.
+    if (overlapsModified) {
+        overlapsModified = false;
+        LocalMultiBlockInfo3D const& localInfo = multiBlockManagement.getLocalInfo();
+        std::vector<Overlap3D> overlaps(multiBlockManagement.getLocalInfo().getNormalOverlaps());
+        for (pluint iOverlap=0; iOverlap<localInfo.getPeriodicOverlaps().size(); ++iOverlap) {
+            PeriodicOverlap3D const& pOverlap = localInfo.getPeriodicOverlaps()[iOverlap];
+            if (periodicity.get(pOverlap.normalX,pOverlap.normalY,pOverlap.normalZ)) {
+                overlaps.push_back(pOverlap.overlap);
+            }
+        }
+        delete communication;
+        communication = new CommunicationStructure3D (
+                                overlaps,
+                                multiBlockManagement, multiBlockManagement,
+                              0 );
+    }
+
+}
+
 void ParallelBlockCommunicator3D::communicate (
         std::vector<Overlap3D> const& overlaps,
         MultiBlock3D const& originMultiBlock,
@@ -262,6 +292,7 @@ void ParallelBlockCommunicator3D::communicate (
         MultiBlock3D const& originMultiBlock,
         MultiBlock3D& destinationMultiBlock, modif::ModifT whichData ) const
 {
+  if (whichData == modif::hemocell_no_comm) { return; }
     global::profiler().start("mpiCommunication");
     bool staticMessage = whichData == modif::staticVariables;
     // 1. Non-blocking receives.
@@ -289,17 +320,77 @@ void ParallelBlockCommunicator3D::communicate (
                 info.toDomain, deltaX, deltaY, deltaZ, fromBlock,
                 whichData, info.absoluteOffset );
     }
+    
+    if (whichData == modif::hemocell) {
+      // 4. Become receptive (dynamic)
+      std::map<CommunicatorEntry*,std::vector<CommunicationInfo3D*>> infos;
+      
+      std::vector<dynamicReceive_t> receives;
+      for (CommunicationInfo3D const& info : communication.recvPackage) {     
+        communication.recvComm.startReceiving(info.fromProcessId,receives,info,infos);
+        
+      }
+      // 5. Receive those messages
+      std::vector<MPI_Request> reqs;
+      for (dynamicReceive_t & recv:receives) {
+        reqs.emplace_back(recv.req);
+      }
+      
+      //Do opportunistic receive
+      while(1) {
+        if (reqs.size() == 0) { break; }
+        int index;
+        MPI_Waitany(reqs.size(),&reqs[0],&index,MPI_STATUS_IGNORE);
+        if (index == MPI_UNDEFINED) {
+          break;
+        }
+        reqs[index] = MPI_REQUEST_NULL;
+        
+        if(!receives[index].pre_req_received) {
 
-    // 4. Finalize the receives.
-    for (unsigned iRecv=0; iRecv<communication.recvPackage.size(); ++iRecv) {
-        CommunicationInfo3D const& info = communication.recvPackage[iRecv];
-        AtomicBlock3D& toBlock = destinationMultiBlock.getComponent(info.toBlockId);
-        toBlock.getDataTransfer().receive (
-                info.toDomain,
-                communication.recvComm.receiveMessage(info.fromProcessId, staticMessage),
-                whichData, info.absoluteOffset );
+          //Got the sizes, wait for data
+          receives[index].pre_req_received = true;
+          
+          CommunicatorEntry & entry = *receives[index].entry;
+          std::vector<int>&messageSizes=receives[index].messageSizes;
+          for (pluint iMessage=0; iMessage<entry.messages.size(); ++iMessage) {
+            int length = messageSizes[iMessage];
+            entry.messages[iMessage].resize(length);
+          }
+    
+          int totalSize = std::accumulate(messageSizes.begin(), messageSizes.end(), 0);
+          entry.totalSize =totalSize;
+          entry.data.resize(totalSize);
+          if (!entry.data.empty()) {
+            global::mpi().iRecv(&entry.data[0], totalSize, receives[index].fromProc,&reqs[index]);
+          }
+        } else {
+          CommunicatorEntry & entry = *receives[index].entry;
+          //5.1 Split in smaller sizes or something
+          int pos=0;
+          for (pluint iMessage=0; iMessage<entry.messages.size(); ++iMessage) {
+            int length = entry.messages[iMessage].size();
+            
+            CommunicationInfo3D const& info = *infos[&entry][iMessage];
+            AtomicBlock3D& toBlock = destinationMultiBlock.getComponent(info.toBlockId);
+            dynamic_cast<hemo::HemoCellParticleDataTransfer&>(toBlock.getDataTransfer()).receive (info.toDomain, 
+                    &entry.data[pos], sizeof(char)*length,
+                  modif::hemocell, info.absoluteOffset );
+            pos+=length;
+          }
+        }
+      }
+    } else { 
+      // 4. Finalize the receives.
+      for (unsigned iRecv=0; iRecv<communication.recvPackage.size(); ++iRecv) {
+          CommunicationInfo3D const& info = communication.recvPackage[iRecv];
+          AtomicBlock3D& toBlock = destinationMultiBlock.getComponent(info.toBlockId);
+          toBlock.getDataTransfer().receive (
+                  info.toDomain,
+                  communication.recvComm.receiveMessage(info.fromProcessId, staticMessage),
+                  whichData, info.absoluteOffset );
+      }
     }
-
     // 5. Finalize the sends.
     communication.sendComm.finalize(staticMessage);
     global::profiler().stop("mpiCommunication");
diff --git a/src/parallelism/parallelBlockCommunicator3D.h b/src/parallelism/parallelBlockCommunicator3D.h
index dee2863..4f12204 100644
--- a/src/parallelism/parallelBlockCommunicator3D.h
+++ b/src/parallelism/parallelBlockCommunicator3D.h
@@ -68,6 +68,7 @@ struct CommunicationStructure3D
             MultiBlockManagement3D const& originManagement,
             MultiBlockManagement3D const& destinationManagement,
             plint sizeOfCell );
+    CommunicationStructure3D ( const CommunicationStructure3D & rhs);
     CommunicationPackage3D sendPackage;
     CommunicationPackage3D recvPackage;
     CommunicationPackage3D sendRecvPackage;
@@ -86,20 +87,22 @@ public:
     void swap(ParallelBlockCommunicator3D& rhs);
     virtual ParallelBlockCommunicator3D* clone() const;
     virtual void duplicateOverlaps(MultiBlock3D& multiBlock, modif::ModifT whichData) const;
+    virtual void duplicateOverlaps(MultiBlockManagement3D&,PeriodicitySwitch3D const& ) const;
+
     virtual void communicate( std::vector<Overlap3D> const& overlaps,
                               MultiBlock3D const& originMultiBlock,
                               MultiBlock3D& destinationMultiBlock,
                               modif::ModifT whichData ) const;
     virtual void signalPeriodicity() const;
-private:
     void communicate( CommunicationStructure3D& communication,
                       MultiBlock3D const& originMultiBlock,
                       MultiBlock3D& destinationMultiBlock, modif::ModifT whichData ) const;
     void subscribeOverlap (
         Overlap3D const& overlap, MultiBlockManagement3D const& multiBlockManagement,
         SendRecvPool& sendPool, SendRecvPool& recvPool, plint sizeOfCell ) const;
-private:
+public:
     mutable bool overlapsModified;
+public:
     mutable CommunicationStructure3D* communication;
 };
 
diff --git a/src/parallelism/sendRecvPool.cpp b/src/parallelism/sendRecvPool.cpp
index 99cd4dc..69a7257 100644
--- a/src/parallelism/sendRecvPool.cpp
+++ b/src/parallelism/sendRecvPool.cpp
@@ -119,8 +119,9 @@ void SendPoolCommunicator::startCommunication(int toProc, bool staticMessage)
                     ( (int)entry.messages[iMessage].size() == entry.lengths[iMessage] ));
         PLB_ASSERT(pos+entry.messages[iMessage].size() <= entry.data.size());
         if( !entry.messages[iMessage].empty() && !entry.data.empty() ) {
-            std::copy(entry.messages[iMessage].begin(),
-                      entry.messages[iMessage].end(), entry.data.begin()+pos);
+          std::memcpy(&entry.data[pos],&entry.messages[iMessage][0],sizeof(char)*entry.messages[iMessage].size());
+            //std::copy(entry.messages[iMessage].begin(),
+            //          entry.messages[iMessage].end(), entry.data.begin()+pos);
         }
         pos+=entry.messages[iMessage].size();
     }
@@ -163,6 +164,24 @@ void RecvPoolCommunicator::startBeingReceptive(bool staticMessage)
     }
 }
 
+void RecvPoolCommunicator::startReceiving(int fromProc, std::vector<dynamicReceive_t> & ret,CommunicationInfo3D const & info,std::map<CommunicatorEntry*,std::vector<CommunicationInfo3D*>>& infos) {
+  std::map<int,CommunicatorEntry>::iterator entryPtr = subscriptions.find(fromProc);
+  CommunicatorEntry& entry = entryPtr->second;
+  infos[&entry].emplace_back(const_cast<CommunicationInfo3D*>(&info));
+  if (entry.currentMessage==0) {
+    ret.emplace_back(const_cast<CommunicationInfo3D*>(&info));
+    ret.back().entry = &entry;
+    ret.back().fromProc = fromProc;
+    pluint numMessages = entry.messages.size();
+    ret.back().messageSizes.resize(numMessages);
+    global::mpi().iRecv(&ret.back().messageSizes[0], numMessages, fromProc,&ret.back().req);
+  }
+  entry.currentMessage++;
+  if (entry.currentMessage==(int)entry.lengths.size()) {
+    entry.reset();
+  }
+}
+
 std::vector<char> const& RecvPoolCommunicator::receiveMessage (
         int fromProc, bool staticMessage )
 {
diff --git a/src/parallelism/sendRecvPool.h b/src/parallelism/sendRecvPool.h
index 89b17c0..6864086 100644
--- a/src/parallelism/sendRecvPool.h
+++ b/src/parallelism/sendRecvPool.h
@@ -41,6 +41,7 @@
 #include "core/globalDefs.h"
 #include "core/util.h"
 #include "parallelism/mpiManager.h"
+#include "communicationPackage3D.h"
 #include <map>
 #include <vector>
 #include <sstream>
@@ -133,6 +134,17 @@ struct CommunicatorEntry {
     int currentMessage;
     MPI_Request sizeRequest, messageRequest;
     MPI_Status  sizeStatus, messageStatus;
+    int totalSize;
+};
+
+struct dynamicReceive_t {
+  MPI_Request req;
+  bool pre_req_received = false;
+  CommunicatorEntry * entry;
+  CommunicationInfo3D * info;
+  std::vector<int> messageSizes;
+  int fromProc;
+  dynamicReceive_t(CommunicationInfo3D * info_) : info(info_) {}
 };
 
 /// The "in-action" device for all messages sent from a processor.
@@ -145,7 +157,7 @@ public:
     void finalize(bool staticMessage);
 private:
     void startCommunication(int toProc, bool staticMessage);
-private:
+public:
     std::map<int, CommunicatorEntry > subscriptions;
 };
 
@@ -156,11 +168,13 @@ public:
     RecvPoolCommunicator(SendRecvPool const& pool);
     /// Initiate non-blocking communication.
     void startBeingReceptive(bool staticMessage);
+    /// Initiate non-blocking for dynamic data since this is perfectly easy (Hack it into palabos)
+    void startReceiving(int fromProc,std::vector<dynamicReceive_t> &, CommunicationInfo3D const&,std::map<CommunicatorEntry*,std::vector<CommunicationInfo3D*>>&);
     std::vector<char> const& receiveMessage(int fromProc, bool staticMessage);
 private:
     void finalizeStatic(int fromProc);
     void receiveDynamic(int fromProc);
-private:
+public:
     std::map<int, CommunicatorEntry > subscriptions;
 };
 
diff --git a/src/particles/particleField3D.h b/src/particles/particleField3D.h
index d781a64..0b66b23 100644
--- a/src/particles/particleField3D.h
+++ b/src/particles/particleField3D.h
@@ -79,6 +79,7 @@ public:
 public:
     /// Helper function: returns if a given particle is situated in the indicated (local) domain.
     bool isContained(Array<T,3> const& particlePos, Box3D box) const;
+    bool isContained(T iX, T iY, T iZ, Box3D box) const;
     void computeGridPosition (
             Array<T,3> const& position,
             plint& iX, plint& iY, plint& iZ ) const;
diff --git a/src/particles/particleField3D.hh b/src/particles/particleField3D.hh
index 9862cda..5bb83f8 100644
--- a/src/particles/particleField3D.hh
+++ b/src/particles/particleField3D.hh
@@ -47,6 +47,20 @@ ParticleField3D<T,Descriptor>::ParticleField3D(plint nx, plint ny, plint nz, Blo
     : AtomicBlock3D(nx,ny,nz, dataTransfer)
 { }
 
+template<typename T, template<typename U> class Descriptor>
+bool ParticleField3D<T,Descriptor>::isContained (
+        T iX, T iY, T iZ, Box3D box ) const
+{
+    Dot3D const& location = this->getLocation();
+    T x = iX-location.x;
+    T y = iY-location.y;
+    T z = iZ-location.z;
+
+    return (x > (T)box.x0-(T)0.5) && (x <= (T)box.x1+(T)0.5) &&
+           (y > (T)box.y0-(T)0.5) && (y <= (T)box.y1+(T)0.5) &&
+           (z > (T)box.z0-(T)0.5) && (z <= (T)box.z1+(T)0.5);
+}
+
 template<typename T, template<typename U> class Descriptor>
 bool ParticleField3D<T,Descriptor>::isContained (
         Array<T,3> const& particlePos, Box3D box ) const
@@ -720,8 +734,10 @@ void LightParticleField3D<T,Descriptor>::swap(LightParticleField3D<T,Descriptor>
 template<typename T, template<typename U> class Descriptor>
 void LightParticleField3D<T,Descriptor>::addParticle(Box3D domain, Particle3D<T,Descriptor>* particle) {
     Box3D finalDomain;
+    Array<T,3> pos; 
+    pos = particle->getPosition();
     if( intersect(domain, this->getBoundingBox(), finalDomain) &&
-        this->isContained(particle->getPosition(), finalDomain) )
+        this->isContained(pos[0],pos[1],pos[2], finalDomain) )
     {
         particles.push_back(particle);
     }
@@ -734,10 +750,12 @@ template<typename T, template<typename U> class Descriptor>
 void LightParticleField3D<T,Descriptor>::removeParticles(Box3D domain) {
     std::vector<Particle3D<T,Descriptor>*> remainingParticles;
     Box3D finalDomain;
+    Array<T,3> pos; 
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+            pos = particles[i]->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 delete particles[i];
             }
             else {
@@ -754,8 +772,10 @@ void LightParticleField3D<T,Descriptor>::removeParticles(Box3D domain, plint tag
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+        Array<T,3> pos; 
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain) &&
+            pos = particles[i]->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain) &&
                 particles[i]->getTag() == tag )
             {
                 delete particles[i];
@@ -774,8 +794,10 @@ void LightParticleField3D<T,Descriptor>::findParticles (
 {
     found.clear();
     PLB_ASSERT( contained(domain, this->getBoundingBox()) );
+    Array<T,3> pos; 
     for (pluint i=0; i<particles.size(); ++i) {
-        if (this->isContained(particles[i]->getPosition(),domain)) {
+        pos = particles[i]->getPosition();
+        if (this->isContained(pos[0],pos[1],pos[2],domain)) {
             found.push_back(particles[i]);
         }
     }
@@ -787,8 +809,11 @@ void LightParticleField3D<T,Descriptor>::findParticles (
 {
     found.clear();
     PLB_ASSERT( contained(domain, this->getBoundingBox()) );
+    Array<T,3> pos; 
+        
     for (pluint i=0; i<particles.size(); ++i) {
-        if (this->isContained(particles[i]->getPosition(),domain)) {
+        pos = particles[i]->getPosition();
+        if (this->isContained(pos[0],pos[1],pos[2],domain)) {
             found.push_back(particles[i]);
         }
     }
@@ -801,8 +826,10 @@ void LightParticleField3D<T,Descriptor>::velocityToParticleCoupling (
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+      Array<T,3> pos;
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+	  pos = particles[i]->getPosition();
+	  if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 particles[i]->velocityToParticle(velocityField, scaling);
             }
         }
@@ -831,8 +858,10 @@ void LightParticleField3D<T,Descriptor>::rhoBarJtoParticleCoupling (
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+      Array<T,3> pos;
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+	  pos = particles[i]->getPosition();
+	  if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 particles[i]->rhoBarJtoParticle(rhoBarJfield, velIsJ, scaling);
             }
         }
@@ -846,8 +875,10 @@ void LightParticleField3D<T,Descriptor>::fluidToParticleCoupling (
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+        Array<T,3> pos;
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+            pos = particles[i]->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 particles[i]->fluidToParticle(lattice, scaling);
             }
         }
@@ -860,13 +891,16 @@ void LightParticleField3D<T,Descriptor>::advanceParticles(Box3D domain, T cutOff
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+        Array<T,3> pos; 
         for (pluint i=0; i<particles.size(); ++i) {
             Particle3D<T,Descriptor>* particle = particles[i];
-            if (this->isContained(particle->getPosition(),finalDomain)) {
+            pos = particle->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 Array<T,3> oldPos( particle->getPosition() );
                 particle->advance();
+                pos = particle->getPosition();
                 if ( (cutOffSpeedSqr>=T() && normSqr(oldPos-particle->getPosition()) < cutOffSpeedSqr) ||
-                     (!this->isContained(particle->getPosition(),this->getBoundingBox()))  )
+                     (!this->isContained(pos[0],pos[1],pos[2],this->getBoundingBox()))  )
                 {
                     delete particle;
                 }
